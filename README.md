# [Algorithms First_contest](https://github.com/PlatonYadrov/Second_semester/tree/main/Algorithms/First_contest)
## [A. Вектор](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/A.cpp)
Даны два ненулевых вектора. Требуется вычислить:  
* Длину первого и второго вектора (два числа)  
* Вектор, образованный сложением данных двух векторов  
* Скалярное и векторное произведения данных векторов  
* Площадь треугольника, построенного из этих векторов

В общем, обычная векторная жизнь.
### Формат ввода:
В двух строках входного файла заданы по четыре целых числа, не превосходящих по модулю 10 000, — координаты начала и конца первого вектора, затем второго.
### Формат вывода:
В каждой строке выходного файла — ответ на соответствующий пункт задачи с точностью не менее 10<sup>-6</sup>.
## [B. Две прямые](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/B.cpp)
Даны коэффициенты A<sub>1</sub>, B<sub>1</sub>, C<sub>1</sub> уравнения первой прямой и коэффициенты A<sub>2</sub>, B<sub>2</sub>, C<sub>2</sub> уравнения второй прямой. Требуется:  
* Построить направляющие векторы для обеих прямых (вывести координаты)  
* Найти точку пересечения двух прямых или вычислить расстояние между ними, если они параллельны
### Формат ввода:
В первой строке входного файла находятся три числа — коэффициенты нормального уравнения для первой прямой. Во второй строке — коэффициенты для второй прямой.  
Все числа во входном файле по модулю не превосодят 10 000.
### Формат вывода:
В каждой строке выходного файла — ответ на соответствующий пункт задачи с точностью не менее 10<sup>-6</sup>.
## [C. Точка и две точки](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/C.cpp)
Определите, принадлежит ли точка C заданной прямой, лучу и отрезку, образованными точками A и B.  
Задумайтесь принадлежит ли вам ваша жизнь.
### Формат ввода:
В первой строке входного файла даны два целых числа — координаты точки C. Во двух следующих строках в таком же формате заданы точки A и B (A ≠ B).  
Все числа во входном файле по модулю не превосодят 10 000.
### Формат вывода:
В первой строке выведите «YES», если точка C принадлежит прямой AB, и «NO» в противном случае. Во второй и третьей строках аналогично выведите ответы для луча AB (A — начало луча) и отрезка AB.
## [D. Расстояния](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/D.cpp)
Даны три точки A, B и C. Необходимо подсчитать расстояния от точки C до прямой, луча и отрезка, образованного точками A и B.
### Формат ввода:
В первой строке входного файла даны два целых числа — координаты точки C. Во двух следующих строках в таком же формате заданы точки A и B (A ≠ B).  
Все числа во входном файле по модулю не превосодят 10 000.
### Формат вывода:
В первой строке выходного файла выведите одно вещественное число — расстояние от точки C до прямой. В следующих двух строках выведите соответственно расстояния до луча AB (A — начало луча) и до отрезка AB. Все числа выводить с точностью не менее 10<sup>-6</sup>. Луч строится по направлению от точки A к точке B.
## [E. Два отрезка](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/E.cpp)
Необходимо проверить, пересекаются ли два отрезка.
### Формат ввода:
В двух строках входного файла заданы по четыре целых числа, не превосходящих по модулю 10 000, — координаты концов первого отрезка, затем второго.
### Формат вывода:
В первой строке выходного файла выведите «YES», если отрезки имеют общие точки, и «NO» в противном случае.
## [F. Отрезки на дистанции](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/F.cpp)
Найдите расстояние между двумя отрезками.
### Формат ввода:
В двух строках входного файла даны по четыре целых числа, не превосходящих по модулю 10 000, — координаты концов сначала первого, затем второго отрезков.
### Формат вывода:
В первой строке выходного файла выведите одно вещественное число — расстояние между отрезками с точностью не менее 10<sup>-6</sup>.
## [G. (Не)выпуклый](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/G.cpp)
Проверьте многоугольник на выпуклость. Задумайтесь над тем, что в 1863 году слово "впуклый" использовалось наравне с словом "выпуклый", но за следующие двести лет сокрушительно проиграло конкуренцию букве "ы".
### Формат ввода:
В первой строке одно число N (3 ≤ N ≤ 100000). Далее в N строках по паре целых чисел — координаты очередной вершины простого многоугольника в порядке обхода по или против часовой стрелки.
Координаты всех точек целые, по модулю не превосходят 10<sup>7</sup>.
### Формат вывода:
Одна строка «YES», если приведённый многоугольник является выпуклым, и «NO» в противном случае.
## [H. Внутри или нет?](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/H.cpp)
Проверьте, лежит ли точка внутри многоугольника.
### Формат ввода:
В первой строке вводятся три целых числа – N (3 ≤ N ≤ 100000) и координаты точки.  
Далее в N строках задается по паре целых чисел – координаты очередной вершины простого многоугольника в порядке обхода по или против часовой стрелки.
### Формат вывода:
Выведите одну строку: «YES», если заданная точка содержится в приведённом многоугольнике или на его границе, и «NO» в противном случае.
## [I. Площадь](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/I.cpp)
Ежегодно в Бостоне совершается более 300 ограблений банков. Большинство этих профессионалов живут в районе с площадью в всего S квадратных миль под названием Чарльзтаун. Найдите эту площадь.
### Формат ввода:
В первой строке одно число N (3 ≤ N ≤ 100 000). Далее в N строках по паре чисел — координаты очередной вершины простого многоугольника в порядке обхода по или против часовой стрелки.  
Координаты целые, по модулю не превосходящие 10<sup>18</sup>.
### Формат вывода:
Одно число — величина площади приведённого многоугольника с точностью 1 знак после запятой.
## [J. Geometry](https://github.com/PlatonYadrov/Second_semester/tree/main/Algorithms/First_contest/Geometry)
В этой задаче необходимо реализовать набор классов для решения геометрических задач на плоскости. Все координаты предполагаются целочисленными.  
`Vector`  
Реализовать класс `Vector` для вектора на плоскости с необходимыми арифметическими операциями (унарные и бинарные `+/-`, умножение/деление на скаляр, присваивающие версии операций, сравнение на равенство).  
`Shape`  
Создать набор классов-фигур, которые наследуются от абстрактного базового класса `IShape` для работы с двумерными геометрическими примитивами:  
•	`Point` (точка);  
•	`Segment` (отрезок);  
•	`Line` (линия);  
•	`Ray` (луч);  
•	`Polygon` (простой многоугольник - часть плоскости, ограниченная замкнутой ломаной без самопересечений);  
•	`Circle` (окружность).  
В базовом классе `IShape` предусмотреть чисто виртуальные методы:  
•	`Move(const Vector&)` - сдвига на заданный вектор, метод должен изменять состояние объекта и возвращать ссылку на сам объект;  
•	`ContainsPoint(const Point&)` - проверка `(true/false)` содержит ли фигура (внутренность фигуры) точку;  
•	`CrossesSegment(const Segment&)` проверка (`true/false`) пересекается ли фигура (граница фигуры) с отрезком;  
•	`Clone()` - копирование объекта (необходимо вернуть умный или обычный указатель на копию фигуры);  
•	`ToString()` - строковое представление фигуры (формат см. в примерах).  
В производных классах - реализовать эти методы. Разность двух точек должна возвращать вектор перемещения одной точки в другую.  
Детали  
Все классы должны располагаться в пространстве имен geometry.  
С публичным интерфейсом классов, который используется в задаче, подробнее можно ознакомиться в файле `geometry_main.cpp`. В частности, Point должен уметь конструироваться от двух целых чисел, `Segment`, `Line` и `Ray` - от двух `Point`, многоугольник - от `std::vector<Point>`, окружность - от центра (`Point`) и радиуса (`int`).  
Объявления классов расположите в соответствующих .h файлах, а необходимые файлы реализации положите в папку `src`. После этого вы можете запустить `geometry_public_test` (по обычной инструкции - через терминал, либо с помощью IDE) и протестировать на различных входных данных. Вы можете прочитать, что принимает программа на вход из файла `geometry_main.cpp` и найти примеры корректной работы на странице задачи в контесте.  
__Где ошибка? Тесты:__  
•	1-6 совпадают с примером  
•	7-15 _Point_  
•	16-46 _Segment_  
•	47-55 _Ray_  
•	56-60 _Line_  
•	61-71 _Polygon_  
•	72-80 _Circle_  
### Формат ввода:
В первой строчке задается тип геометрического примитива: _point_, _segment_, _ray_, _line_, _circle_ или _polygon_. Далее вводится сам примитив.
После чего вводится две точки A и B, которые используются в CheckFunctionsCheckFunctions. Все числа целочисленные и не превосходят 10000 по модулю.
Для Point выводятся ее координаты; Segment - два конца (точки); Ray - начало (точка) и направляющий вектор; Line - коэффициенты уравнения прямой (ax + by + c) с точностью до некоторого множителя (по идее система должна принимать и Line(1, −1, 1), и Line(−2, 2, −2)); Polygon - последовательность вершин; Circle - центр и радиус.
## [K. Выпуклая оболочка](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/K.cpp)
Дано N точек на плоскости. Нужно построить их выпуклую оболочку, используя алгоритм Грэхема.  
Гарантируется, что выпуклая оболочка не вырождена.
### Формат ввода:
На первой строке число N (3 ≤ N ≤ 10<sup>5</sup>). Следующие N строк содержат пары целых чисел x и y (-10<sup>9</sup> ≤ x, y ≤ 10<sup>9</sup>) — точки.  
Будьте аккуратны! Точки произвольны. Бывают совпадающие, бывают лежащие на одной прямой в большом количестве.
### Формат вывода:
В первой строке выведите K — число вершин выпуклой оболочки. Следующие K строк должны содержать координаты вершин в порядке обхода. Никакие три подряд идущие точки не должны лежать на одной прямой.  
Кроме того, в последней строке выведите площадь получившейся выпуклой оболочки. Площадь необходимо вывести c точностью 1 знак после запятой.
## [L. Выпуклая оболочка. Возвращение легенды](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/L.cpp)
Дано N точек на плоскости. Нужно построить их выпуклую оболочку. Всё то же самое, но по-другому. В этот раз реализуйте алгоритм Джарвиса.  
Гарантируется, что выпуклая оболочка не вырождена.
### Формат ввода:
На первой строке число N (3 ≤ N ≤ 10<sup>5</sup>). Следующие N строк содержат пары целых чисел x и y (-10<sup>9</sup> ≤ x, y ≤ 10<sup>9</sup>) — точки.  
Будьте аккуратны! Точки произвольны. Бывают совпадающие, бывают лежащие на одной прямой в большом количестве.
### Формат вывода:
В первой строке выведите K — число вершин выпуклой оболочки. Следующие K строк должны содержать координаты вершин в порядке обхода. Никакие три подряд идущие точки не должны лежать на одной прямой.  
Кроме того, в последней строке выведите площадь получившейся выпуклой оболочки. Площадь необходимо вывести c точностью 1 знак после запятой.
## [M. Инфекция](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/M.cpp)
Неизвестная инфекция начала распространяться по всей столице. Известно, что она распространяется почти одинаково во все стороны, поэтому было решено разбить город на зоны, чтобы лучше мобилизовать ресурсы в случае внештатной ситуации.  
Студент Артур долго работал над такой моделью и выяснил, что лучше всего разбить город следующим образом. Задано множество точек размера N — социально значимых объектов в столице. По этому множеству точек разбиение строится так:  
1.	строится выпуклая оболочка на этом множестве, потом все точки, что в нее попали (или на ее границу) выбрасываются.  
2.	повторяют первый шаг, пока не останется два или меньше социально значимых объектов.

То есть по индукции построили множество выпуклых оболочек. Точка лежит в зоне с номером i, если она лежит внутри i-й оболочки и не лежит внутри (i + 1)-й оболочки. Точка лежит в оболочке, если попадает на ее границу или лежит внутри. Зоны нумеруются с нуля, так как там еще нет инфекции.  
Ученые заинтересовались его исследованием и решили, что это действительно хорошая модель разбиения, так как точки подобраны согласно последним данным о распространении инфекции. Теперь им стало интересно, в какой зоне будут лежать научно важные объекты, например, университеты или лаборатории. Всего таких объектов K, а так как таких объектов очень много, ученые попросили автоматизировать процесс. Справитесь ли вы с этим поручением?  
### Формат ввода:
В первой строке вам дается число N (3 ≤ N ≤ 10<sup>3</sup>) — количество социально значимых объектов для разбиения города на зоны.  
Далее идут N строк по два целых числа через пробел (x<sub>i</sub>, y<sub>i</sub>) (-10<sup>9</sup> ≤ x<sub>i</sub>, y<sub>i</sub> ≤ 10<sup>9</sup>) — координаты очередного социально значимого объекта. Гарантируется, что одинаковых точек нет. Считайте, что точки, лежащие снаружи нулевой оболочки лежат в нулевой зоне.
На следующей строке идет число K (1 ≤ K ≤ 10<sup>9</sup>) — количество научно значимых объектов, про которые ученым надо знать их зону.
Далее идут K строк по два целых числа через пробел (x<sub>i</sub>, y<sub>i</sub>) (-10<sup>9</sup> ≤ x<sub>i</sub>, y<sub>i</sub> ≤ 10<sup>9</sup>) — координаты университетов, лабораторий …
### Формат вывода:
Выведите K строк из одного целого числа, где на i-й строке номер зоны i-го научно значимого объекта.
## [N. Радио](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/N.cpp)
Компания «Аудио Квадрат» захватила значительную долю рынка музыкальных товаров и услуг. В частности она делает персональное радио для каждого человека, которое учитывает его музыкальные предпочтения и текущее настроение.

Но параллельно, just for fun, компания запускает проект общественного радио. Это радио, в котором песня выбирается в соответствии с пожеланиями множества проголосовавших пользователей.

Алгоритм общественного радио безумно прост. Посетители интернет сайта «Аудио Квадрата» постоянно голосуют за отдельные композиции (с одного IP можно проголосовать в течении 10 минут только за одну композицию). Голос может иметь вес score. Для каждой композиции считаются очки — track_score. Следующей композицией, которая будет играть на радио, станет та, которая имеет максимальное количество очков. Если таких композиций несколько, то должна играть та, которая имеет минимальный идентификатор. В момент, когда композиция запускается на радио, её track_score становится равным -1.

Чтобы исключить попытки накручивания счётчика определёнными группами лиц, компания решила принимать голоса с одного IP не чаще раза в 10 минут (два голоса могут быть приняты, если между ними не менее шестисот секунд).

Вы являетесь главным разработчиком компании «Аудио Квадрат». И хотя у вас в подчинении множество высококлассных программистов, вы решили вспомнить старые добрые времена и запрограммировать этот алгоритм сами.

Общественных радио будет много, поэтому важно, чтобы каждое из них работало достаточно эффективно, то есть не отнимало много процессорных ресурсов и оперативной памяти.

Необходимо написать программу, реализующую алгоритм работы одного общественного радио. Взаимодействие с программой будет осуществляться через стандартный поток ввода/вывода согласно заданному ниже протоколу.

Для решения этой задачи используйте ассоциативные контейнеры и очереди с приоритетами.
### Формат ввода:
Каждая строчка входа — это определенная команда. Всего 3 типа команд:  
•	VOTE ip track_id score time  
•	GET  
•	EXIT  
Команда V OT E меняет число очков track_score определённой композиции. Она получает четыре аргумента:  
• ip — IP адрес компьютера, с которого пришел голос; четыре целых числа из промежутка [0, 255], разделённых точкой  
• track_id — численный идентификатор композиции; натуральное число из отрезка [1, 2 · 107 ];  
• score — количество очков, которое нужно добавить к текущим очкам композиции track_score — целое число из отрезка [−100, 100];  
• time — момент времени в секундах от некоторого фиксированного момента времени — целое число из промежутка [0, 2 · 109 ].  
На команду VOTE нужно отвечать новым значением очков музыкальной композиции track_id (даже если эти очки не изменились).  
Команда GET используется для получения следующей композиции. Ваша программа должна отвечать на неё парой track_id и track_score (вывести эти два числа в одной строке, разделив их пробелом). Сразу после выполнения этой команды новое значение track_score для этой композиции должно стать равным -1.  
Команда EXIT находится в последней строке входа. При её получении необходимо вывести строку «OK». Число команд на входе не более 100001. Изначально значение track_score для всех композиций равно 0.  
Команды во входных данных упорядочены по параметру time (для двух из трёх команд этот параметр просто не передаётся, так как не нужен).
### Формат вывода:
Выход должен содержать ровно столько же строчек, что и вход. Каждая строчка выхода — это ответ на соответствующую команду из входа.
# [Cpp First_contest](https://github.com/PlatonYadrov/Second_semester/tree/main/cpp/First_contest)
## [A. String](https://github.com/PlatonYadrov/Second_semester/tree/main/cpp/First_contest/string)
_В качестве решения ожидается zip архив с решением (даже если решение состоит из одного файла). Присылайте файлы только с ВАШИМ кодом, то есть файлы с тестами и CMakeLists.txt присылать не нужно._  
### Условие
Напишем класс динамической саморасширяющейся строки, заодно познакомимся со стандартным классом `std::string`.

`std::string`
Класс `std::string` предоставляет удобный и безопасный интерфейс работы со строками в `C++`. Одна из главных проблем стековых и выделяемых в куче строк (массивов char) заключается в том, что они имеют фиксированный размер и не умеют автоматически расширяться при необходимости. При создании строк в динамической области возникает потребность в ручном отслеживании возможных утечек памяти, что накладывает дополнительные сложности на процесс разработки. Кроме того, `C-style` строки не хранят информацию о своем размере, что тоже не упрощает взаимодействие с ними.  

Эти проблемы можно обойти, используя ООП функционал `C++`. В частности, механизм инкапсуляции позволяет хранить размер строки в отдельном поле, реализовать методы, при вызове которых массив будет автоматически расширяться, создавая иллюзию неограниченной строки, а механизмы работы с ресурсами гарантируют своевременное выделение и очищение памяти.  

#### Пример:

`std::string s = "hello"`;  
`s.Size()`;        // 5, работает за O(1)  
`s[0] = 'H'`;  
`s += ", world!"`  // строка расширяется  
`std::cout << s`;  // "Hello, world!"  
Подробнее о возможностях `std::string` [здесь](https://en.cppreference.com/w/cpp/string/basic_string).

### Задание
Реализуйте класс динамической строки - аналог std::string, с эффективной стратегией расширения (мультипликативная схема).

Введем понятия "размера" строки (`size`) и ее "вместимости" (`capacity`). `С++` в каждый момент времени позволяет поддерживать массивы конечной вместимости (сколько выделено памяти), при этом фактический размер (количество реально используемых символов) может быть меньше этого значения. Почему бы постоянно не поддерживать равенство между этими величинами? - Это не эффективно. Допустим, мы добавляем символы в конец строки по одному. Тогда при каждом обновлении будет происходить перевыделение исходной памяти с последующим копированием всех старых элементов в новый буфер. Легко видеть, что в этом случае общее число копирований будет квадратичным образом зависеть от числа добавленных элементов. Оказывается, что, если при каждом переполнении массива увеличивать его вместимость в константное число раз, то можно добиться линейной зависимости числа операций над массивом от числа добавляемых элементов. В вашем решении будет проверяться корректность работы данной схемы при множителе равном 2 (то есть, при переполнении буфера его вместимость должна увеличиваться __минимум в 2 раза__).

### Детали реализации
Реализуйте класс String со следующим интерфейсом:  
*	Конструктор по умолчанию - создает пустую строку (`nullptr`);
*	Конструктор, принимающий `size` и `symbol`, - создает строку длины `size`, заполненную символами `symbol`.
*	Конструктор, принимающий `С-style` строку (`const char*`) и создающий на ее основе строку. Этот конструктор должен уметь выполнять неявные преобразования, поэтому не нужно объявлять его `explicit`. Это не понравится кодстайл чекеру, поэтому к строке с объявлением добавьте комментарий `// NOLINT`, чтобы он проигнорировал эту строку.  
*	Конструктор, принимающий массив `char` (`const char*`) и количество первых символов (`size`), которые нужно скопировать.  
*	Правило "трех".  
*	Константный и неконстантный оператор доступа по индексу `[]`. Последний должен позволять изменять полученный символ (`s[0] = 'H'`);  
*	Константный и неконстантный метод доступа по индексу `At`. При выходе за границы строки должен бросать исключение `StringOutOfRange`, которое написано за вас (об этом ниже).  
*	Методы `Front()` и `Back()`
    * доступ к первому и последнему символам (тоже по две версии).

*	Методы `CStr()` и `Data()`  
    * возвращают указатель на начало строки (`C-style` строку).  
*	Метод `Empty()`  
    * `true`, если строка пуста (размер 0).  
*	Методы `Size()` и `Length()`  
    * размер строки.  
*	Метод `Capacity()`  
    * текущая вместимость.  
*	Метод `Clear()`  
    * устанавливает размер в 0, удаления выделенной памяти при этом НЕ происходит.  
*	Метод `Swap(other)`  
    * обменивает содержимое с другой строкой `other`.  
*	Метод `PopBack()`  
    * удаляет последний символ.  
* Метод `PushBack(symbol)`  
    * добавляет символ symbol в конец строки (при необходимости строка расширяется).  
*	Операция `+=`  
    * принимает другую строку (`String`) и приписывает ее в конец текущей.  
*	Метод `Resize(new_size, symbol)`  
   	* изменяет размер на `new_size`. Если вместимость не позволяет хранить столько символов, то выделяется новый буфер с вместимостью `new_size`. В случае `new_size > size` заполняет недостающие символы значением `symbol`.  
*	Метод `Reserve(new_capacity)`  
    * изменяет вместимость на `max(new_capacity, текущая вместимость)`. Размер при этом не изменяется.  
*	Метод `ShrinkToFit()`  
    * уменьшает `capacity` до `size` (убирает излишек).  
*	Конкатенация с помощью операции `+`.  
*	Операции сравнения `(<, >, <=, >=, ==, !=)`, задающие лексикографический порядок.  
*	Операция вывода в поток.  
#### Замечания.
1.	Решение должно состоять из файлов `cppstring.h` и `cppstring.cpp`.  
2.	В этой задаче запрещается использование стандартной библиотеки `C++`. Если нужны какие-либо служебные классы или функции, реализуйте их самостоятельно.
3.	Проверка устроена таким образом, что требует от вас жесткого следования принятым (выше) сигнатурам и именованиям сущностей (то есть никакие `MyString`, `__string_`, `push_back`, `superSolver3000` не пройдут). Если вы реализовали требуемый функционал не полностью или интерфейс отличается от заявленного, вы получите ошибку компиляции.
4.	В тесты включены проверки функциональности (методы работают так как требует условие), проверка эффективности реализации (что значит эффективно описано выше), проверка корректности работы с памятью (утечки памяти, обращения к памяти не принадлежащей процессу будут приводить к провалу).
5.	"Бросить исключение типа E" значит - написать строку `throw E{}`;. В этот момент выполнение функции прекращается и, если исключение не будет обработано, программа завершится аварийно. Тестирующий код корректно обработает эту ошибку, вам этого делать не нужно.
## [B. UniquePtr](https://github.com/PlatonYadrov/Second_semester/blob/main/cpp/First_contest/B.h)
### Условие
_С++ предоставляет шаблонный класс std::unique_ptr (https://en.cppreference.com/w/cpp/memory/unique_ptr) для безопасной работы с динамически выделенной памятью (и другими ресурсами). В std::unique_ptr перегружены все необходимые операции для комфортной работы с объектами так, как если бы это были обычные указатели (которые еще память за собой очищают). Объекты этого класса считаются единственными владельцами ресурса, на который они указывают, поэтому эти объекты нельзя копировать, но можно перемещать - передавать владение другому объекту. Использование std::unique_ptr почти не накладывает дополнительных вычислительных расходов, поэтому пользоваться им так же эффективно, как и обычными указателями, и при этом гораздо безопаснее._  
#### Пример:
```
#include <memory>

// ...

std::unique_ptr<int> ptr(new int(10));

std::cout << *ptr << '\n';  // 10

// std::unique_ptr<int> copy = ptr; копирование запрещено

std::unique_ptr<int> moved = std::move(ptr);  // теперь ptr пуст

std::cout << *moved << '\n';  // 10

auto rational = std::make_unique<Rational>(1, 2);

// эквивалентно std::unique_ptr<Rational> rational(new Rational(1, 2));

std::cout << rational->Numerator() << ' ' << rational->Denominator() << '\n';  // 1 2

// delete вызовутся автоматически в деструкторах!
```
#### Задание
Реализуйте шаблон `UniquePtr` - упрощенный аналог класса умного указателя с уникальным владением, `std::unique_ptr (C++11)`.  
### Детали реализации
Шаблонный класс должен поддерживать:  
•	Конструктор по умолчанию (создает нулевой указатель).  
•	Конструктор от указателя (сохраняет указатель на объект).  
•	Конструктор копирования и копирующее присваивание должны отсутствовать.  
•	Перемещающий конструктор и перемещающее присваивание должны передавать владение объектом.  
•	Метод `Release()`, который отлучает класс от владения текущим ресурсом и возвращает указатель на него.  
•	Метод `Reset(T* ptr = nullptr)`, меняет указатель, которым владеет объект (старый ресурс удаляется).  
•	Метод `Swap(UniquePtr<T>&)`.  
•	Метод `Get()`, возвращающий указатель на объект.  
•	Оператор разыменовывания `operator*`.  
•	Оператор "стрелочка" `operator->`.  
•	Явный оператор приведения к `bool (operator bool)`.  
#### Замечания.
•	https://en.cppreference.com/w/cpp/memory/unique_ptr  
•	Решение должно состоять из одного файла `unique_ptr.h`
## [C. SharedPtr](https://github.com/PlatonYadrov/Second_semester/blob/main/cpp/First_contest/C.h)
_Умные указатели реализуют важную идиому C++ - RAII (Resource Acquisition Is Initialization) и позволяют не заботиться о ручном управлении памятью, так как инкапсулируют управление ресурсами посредством конструкторов и деструкторов._

`std::shared_ptr (C++11)`  
Шаблонный класс `std::shared_ptr` предоставляет интерфейс указателя на данные в динамической области с автоматическим контролем своевременного выделения и удаления ресурсов. В отличие от `std::unique_ptr`, `std::shared_ptr` реализует семантику разделяемого владения ресурсом, что означает, что у одного ресурса может быть несколько равноправных владельцев. При этом гарантируется, что ресурс не будет освобожден пока существует хотя бы один его владелец (хотя бы один объект `std::shared_ptr` указывает на ресурс). Для решения проблемы циклических ссылок в язык также введены "слабые указатели" `std::weak_ptr`, которые не считаются полноценными владельцами ресурса, но из них при необходимости можно получить "сильный указатель" `std::shared_ptr` на объект, если тот еще не удален.  

Несмотря на то, что `std::shared_ptr` удобнее в использовании чем `std::unique_ptr`, на практике последний работает гораздо эффективней - `std::shared_ptr` реализует дополнительную логику с подсчетом ссылок на объект. Поэтому `std::shared_ptr` стоит использовать только тогда, когда вам действительно нужно разделяемое владение.
#### Задание
Реализуйте шаблон SharedPtr - упрощенный аналог класса умного указателя с разделяемым владением.

Идея реализации: помимо самого указателя на выделенный ресурс необходимо знать число "сильных" и "слабых" ссылок на объект. Для этого в куче выделим специальную счетчик strong_counter, который будет хранить эту информацию (при создании нового указателя соответствующий счетчик увеличивается, при удалении - уменьшается; если число сильных ссылок стало равно 0, то объект удаляется).
### Детали реализации
Детали обсуждались на лекции и семинарах. Шаблонный класс `SharedPtr` должен поддерживать:  
•	Конструктор по умолчанию (создает нулевой указатель).  
•	Конструктор от указателя (сохраняет указатель на владеемый объект).  
•	Конструктор копирования и копирующее присваивание (создают новую ссылку на тот же объект).  
•	Перемещающий конструктор и перемещающее присваивание должны передавать владение объектом.  
•	Метод `Reset(T* ptr = nullptr)`, меняет указатель, которым владеет объект.  
•	Метод `Swap(SharedPtr<T>&)`.  
•	Метод `Get()`, возвращающий указатель на владеемый объект.  
•	Метод `UseCount()`, возвращающий число "сильных" ссылок на объект.  
•	Оператор разыменовывания `operator*`.  
•	Оператор "стрелочка" `operator->`.  
•	Явный оператор приведения к `bool (operator bool)`.
#### Замечания.
•	https://en.cppreference.com/w/cpp/memory/shared_ptr  
•	Решение должно состоять из одного файла `shared_ptr.h`
## [F. Calculator.Tokenize](https://github.com/PlatonYadrov/Second_semester/tree/main/cpp/First_contest/Tokenize)
_Когда говорят "компьютерная программа", одно из первых, что приходит на ум, - калькулятор. Действительно, изначальное назначение компьютеров - производить математические вычисления. И кажется, это настолько базовая задача, что написать калькулятор на любом известном вам языке программирования не составляет никакого труда. Тем не менее оказывается, что это не такая уж тривиальная и скучная задача. Как, например, вычислить значение, заданное входом "1 * (((2 * 3) * (4 + 5) + 6 + 7) * (8 * 9 + 10 * 11) * 12)"? Данная задача в трех частях ответит на этот вопрос._
### Tokenize
Первым шагом практически в любой задаче, работающей с пользовательским вводом, является токенизация - разбиение исходного текста на отдельные смысловые части (например, фразы, слова, буквы). В нашей задаче в качестве токенов будут выступать математические символы.

Всего рассмотрим 13 типов токенов: `"+" (PlusToken), "-" (MinusToken), "*" (MultiplyToken), "/" (DivideToken), "%" (ResidualToken), "(" (OpeningBracketToken), ")" (ClosingBracketToken), "sqr" (SqrToken), "max" (MaxToken), "min" (MinToken), "abs" (AbsToken), "23" (NumberToken, здесь произвольное число), "abracadabra" (UnknownToken)`.

Для каждого типа токена необходимо завести свою структуру (название написано в скобках). Все структуры могут быть пустыми, за исключением `NumberToken`, который дополнительно в `int` поле value должен хранить значение числа, и `UnknownToken`, который в строковом поле `value` должен хранить значение неизвестного токена.

Чтобы хранить все токены в одном контейнере необходимо привести все значения к одному типу. Мы бы могли вновь воспользоваться наследованием и хранить указатель на базовый класс, но в этом задании мы познакомимся с классом `std::variant (C++17)`, который может хранить в себе значение одного из заранее заданных типов (ООП аналог `union`).
#### std::variant (C++17)
https://en.cppreference.com/w/cpp/utility/variant  
`std::variant` - шаблонный класс, который может хранить в себе произвольное значение одного из нескольких указанных в шаблоне типов. Основные функции, которые вам понадобятся:
•	`std::get<T>` принимает тип `T` в качестве параметра шаблона и объект `std::variant` в качестве аргумента. Если тип хранимого в данный момент объекта совпадает с указанным, то возвращается значение, иначе бросается исключение `std::bad_variant_access`;  
•	`std::holds_alternative<T>` проверяет лежит ли в данный момент в объекте значение типа `T` и возвращает `true` или `false` в зависимости от результата;  
•	`operator==` возвращает `true`, если для хранимых объектов совпадают типы и их значения.  
Остальные методы и функции можете найти в документации.
#### Пример:
```
std::variant<int, std::string> v;  // объект может хранить в себе либо int, либо std::string

v = 5;  // сейчас в нем хранится int

if (std::holds_alternative<int>(v)) std::cout << std::get<int>(v);  // на экране "5"

v = std::string("aba");  // теперь хранится std::string

std::get<int>(v);  // бросается исключение (хранится не int)

v = std::array<int, 3>();  // ошибка компиляции (v не может хранить std::array<int, 3>)
```
#### Детали реализации
В файле `tokenize.h` объявите и определите описанные выше структуры и заведите тип `Token`, который может хранить любой тип токена, как псевдоним `std::variant<PlusToken, MinusToken,... (и т.д.)>` (с помощью `using`). Не забудьте определить оператор сравнения на равенство для каждого типа токена, чтобы сравнение двух токенов в тестах работало нормально (для токенов, которые ничего не хранят, сравнение на `==` должно просто возвращать `true`).

Основное задание заключается в написании функции `std::vector<Token> Tokenize(std::string_view)`, которая принимает строку и возвращает последовательность токенов в ней.

Опишите прототип в файле `tokenize.h`, а реализацию и необходимые побочные функции в `tokenize.cpp`.

Для простоты будем считать, что все токены разделены произвольным ненулевым количеством пробелов.
# [Algorithms Second_contest](https://github.com/PlatonYadrov/Second_semester/tree/main/Algorithms/Second_contest)
## [A. Кратчайший путь](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/A.cpp)
Вам дан неориентированный граф. Найдите кратчайший путь от вершины a до вершины b.
### Формат ввода:
В первой строке входного файла идут целые числа n и m (1 ≤ n ≤ 50 000, 1 ≤ m ≤ 100 000) — количества вершин и рёбер соответственно. Во второй строке идут целые числа a и b — стартовая и конечная вершины соответственно. Далее идут m строк, описывающих рёбра.
### Формат вывода:
Если пути между a и b нет, выведите единственное число -1. Иначе выведите в первой строке число l — длину кратчайшего пути между этими двумя вершинами в рёбрах, а во второй строке выведите l + 1 число — вершины этого пути.
## [B. Нет списыванию](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/B.cpp)
Во время контрольной работы профессор Флойд заметил, что некоторые студенты обмениваются записками. Сначала он хотел поставить им всем двойки, но в тот день профессор был добрым, а потому решил разделить студентов на две группы: списывающих и дающих списывать, и поставить двойки только первым.  
У профессора записаны все пары студентов, обменявшихся записками. Требуется определить, сможет ли он разделить студентов на две группы так, чтобы любой обмен записками осуществлялся от студента одной группы студенту другой группы.
### Формат ввода:
В первой строке находятся два числа N и M — количество студентов и количество пар студентов, обменивающихся записками (1 ≤ N ≤ 100, 0 ≤ M ≤ N ⋅ (N - 1) / 2). Далее в M строках расположены описания пар студентов: два числа, соответствующие номерам студентов, обменивающихся записками (нумерация студентов идёт с 1). Каждая пара студентов перечислена не более одного раза.
### Формат вывода:
Необходимо вывести ответ на задачу профессора Флойда. Если возможно разделить студентов на две группы — выведите YES; иначе выведите NO.
## [C. Очередная задача с ЕГЭ](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/C.cpp)
Витя хочет придумать новую игру с числами. В этой игре от игроков требуется преобразовывать четырехзначные числа не содержащие нулей при помощи следующего разрешенного набора действий:  
1.	Можно увеличить первую цифру числа на 1, если она не равна 9.  
2.	Можно уменьшить последнюю цифру на 1, если она не равна 1.  
3.	Можно циклически сдвинуть все цифры на одну вправо.  
4.	Можно циклически сдвинуть все цифры на одну влево.

Например, применяя эти правила к числу 1234 можно получить числа 2234, 1233, 4123 и 2341 соответственно. Точные правила игры Витя пока не придумал, но пока его интересует вопрос, как получить из одного числа другое за минимальное количество операций.
### Формат ввода:
Во входном файле содержится два различных четырехзначных числа, каждое из которых не содержит нулей.
### Формат вывода:
В первой строке вывода должна быть длина оптимальной последовательности чисел, которая описана ниже.  
На второй строке необходимо вывести последовательность четырехзначных чисел, не содержащих нулей. Последовательность должна начинаться первым из данных чисел и заканчиваться вторым из данных чисел, каждое последующее число в последовательности должно быть получено из предыдущего числа применением одного из правил. Количество чисел в последовательности должно быть минимально возможным.
## [D. Найти саб](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/D.cpp)
В славном городе Нью-Йорке в не менее славном районе Манхэттен на некоторых перекрестках установлены рестораны сети Subway. Также в этом районе на каждом перекрестке установлены офисные здания.  
Для упрощения дел, будем считать Манхэттен районом, где все дороги идут перпендикулярно, а сам он имеет вид прямоугольника размера N × M перекрестков. Расстояние между клетками с координатами (x<sub>1</sub>, y<sub>1</sub>), (x<sub>2</sub>, y<sub>2</sub>) равно числу участков дорог, которые надо проехать (или |x<sub>1</sub> - x<sub>2</sub>| + |y<sub>1</sub> - y<sub>2</sub>|).  
Нужно по расположению ресторанов Subway узнать для каждого перекрестка минимальное расстояние от него до одного из ресторанов. Гарантируется, что хотя бы один ресторан имеется в Манхэттене.
### Формат ввода:
В первой строке вводятся два натуральных числа N и M, не превосходящих 1000 — размеры Манхэттена. Далее идут N строк по M чисел — карта перекрестков района, где 1 означает наличие ресторана на этом перекрестке, и 0 — его отсутствие.
### Формат вывода:
Требуется вывести N строк по M чисел, где для каждого перекрестка указано расстояние до ближайшего Саба.
## [E. Найти минимальный путь](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/E.cpp)
Дан ориентированный взвешенный граф. Найдите кратчайшее расстояние от одной заданной вершины до другой.
### Формат ввода:
В первой строке входного файла два числа: N и M (1 ≤ N ≤ 100, 0 ≤ M ≤ 10000), где N — количество вершин графа, а M — количество ребер.  
В следующей строке заданы числа S и F — начальная и конечная вершины.  
Далее следует M троек чисел A<sub>i</sub>, B<sub>i</sub>, T<sub>i</sub> (1 ≤ T<sub>i</sub> ≤ 10) — номера вершин соединенных ребром и вес данного ребра.
### Формат вывода:
Вывести искомое расстояние или -1, если пути между указанными вершинами не существует.
## [F. ПДД](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/F.cpp)
В столице одной небольшой страны очень сложная ситуация. Многокилометровые пробки буквально парализовали движение в городе, и власти на многих улицах ввели одностороннее движение, не анализируя, можно ли будет теперь проехать из любого места в городе в любое другое, не нарушая правила. Транспортная система столицы представляет собой N площадей, соединенных M полосами для движения, в том числе круговыми полосами, проходящими по площади. Каждая полоса предназначена для движения только в одну определенную сторону. При этом на магистралях есть полосы, направленные как в одну, так и в другую сторону. По круговой полосе можно двигаться только внутри площади и только против часовой стрелки.

Власти города на каждой полосе разместили видеокамеру, поэтому если Иннокентий едет по встречной полосе (при ее наличии) или, в случае одностороннего движения, в сторону противоположную предписанной знаками, то после поездки против правил по каждой из полос ему придется заплатить штраф в размере одной тысячи тугриков этой страны.

Иннокентий, который торопится купить кафельную плитку со скидкой, решился доехать до магазина в любом случае, даже если для этого придется нарушать правила. Но он хочет выбрать такой маршрут движения, суммарный штраф на котором минимален.

Иннокентий еще не решил, откуда именно и в какой магазин он собирается ехать, поэтому ему необходимо ответить на несколько вопросов вида «Какой минимальный штраф надо заплатить, чтобы добраться из пункта A в пункт B?». Отвечая на потребности жителей столицы, известная поисковая система Индекс разрабатывает соответствующий сервис.

Так как многие из вас рано или поздно будут проходить собеседование на работу в эту фирму, продемонстрируйте, что вы тоже умеете решать эту задачу.
### Формат ввода:
В первой строке входных данных содержатся два числа N и M — количество площадей и полос движения в городе соответственно (1 ≤ N ≤ 5000, 1 ≤ M ≤ 10 000). Далее содержатся описания полос, по которым движение разрешено. Каждая полоса описывается номерами двух площадей, которые она соединяет. Движение разрешено в направлении от первой из указанных площадей ко второй.  
В следующей строке содержится одно число K — количество вопросов у Иннокентия (1 ≤ K ≤ 10 000, N ⋅ K ≤ 2 ⋅ 10<sup>7</sup>). В следующих строках описываются вопросы, каждый вопрос описывается номерами двух площадей, между которыми требуется найти самый дешевый путь. Путь необходимо проложить от первой из указанных площадей ко второй.
### Формат вывода:
Для каждого вопроса выведите одно число — искомый минимальный размер штрафа в тысячах тугриков. В случае, если пути между выбранной парой площадей не существует, выведите - 1.
## [G. Найти цикл](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/G.cpp)
Дан ориентированный невзвешенный граф. Необходимо определить есть ли в нём циклы, и если есть, то вывести любой из них.
### Формат ввода:
В первой строке входного файла находятся два натуральных числа N и M (1 ≤ N ≤ 100000, M ≤ 100000) — количество вершин и рёбер в графе соответственно. Далее в M строках перечислены рёбра графа. Каждое ребро задаётся парой чисел — номерами начальной и конечной вершин соответственно.
### Формат вывода:
Если в графе нет цикла, то вывести NO, иначе — YES и затем перечислить все вершины в порядке обхода цикла.
## [H. Свинки-копилки](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/H.cpp)
У Васи есть N свинок-копилок, свинки занумерованы числами от 1 до N. Каждая копилка может быть открыта единственным соответствующим ей ключом или разбита.

Вася положил ключи в некоторые из копилок (он помнит, какой ключ лежит в какой из копилок). Теперь Вася собрался купить машину, а для этого ему нужно достать деньги из всех копилок. При этом он хочет разбить как можно меньшее количество копилок (ведь ему еще нужно копить деньги на квартиру, дачу, вертолет...). Помогите Васе определить, какое минимальное количество копилок нужно разбить.
### Формат ввода:
В первой строке содержится число N — количество свинок-копилок (1 ≤ N ≤ 100). Далее идет N строк с описанием того, где лежит ключ от какой копилки: в i-ой из этих строк записан номер копилки, в которой находится ключ от i-ой копилки.
### Формат вывода:
Выведите единственное число: минимальное количество копилок, которые необходимо разбить.
## [I. Залетаем в чатики](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/I.cpp)
Вам нужно распространить новость о посвяте среди всех первокурсников. Известно, что первокурсники общаются друг с другом через чаты, при этом если новость вброшена в чат, то гарантируется что все его участники прочтут новость (эх, было бы так не только в условии этой задачи).  
Так как у вас уже и так очень много своих чатов, вы хотите вступить в как можно меньшее их количество, чтобы все первокурсники узнали, что посвят уже скоро. При этом вам неизвестны составы чатов, но до вас дошли сведения, что некоторые пары первокурсников гарантированно сидят в одном чате. Более того, если студент сидит в чате и видит новость, то он пересылает сообщение с важной информации во все остальные чаты, где он есть.
### Формат ввода:
Во входном файле записано два числа N — число первокурсников и M — число известных вам пар первокурсников, сидящих в одном чате (1 ≤ N ≤ 100000, 0 ≤ M ≤ 100000). В следующих M строках записаны по два числа i и j (1 ≤ i, j ≤ N), которые означают, что первокурсники с номерами i и j в одном чате.
### Формат вывода:
В первой строчке выходного файла выведите количество чатов, куда вам надо вступить. Далее выведите группы студентов, которые узнают о новости для каждого вступления в чат: в первой строке количество студентов в такой группе в компоненте, во второй — номера студентов в произвольном порядке.
