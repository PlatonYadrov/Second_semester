# [Algorithms First_contest](https://github.com/PlatonYadrov/Second_semester/tree/main/Algorithms/First_contest)
## [A. Вектор](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/A.cpp)
Даны два ненулевых вектора. Требуется вычислить:  
* Длину первого и второго вектора (два числа)  
* Вектор, образованный сложением данных двух векторов  
* Скалярное и векторное произведения данных векторов  
* Площадь треугольника, построенного из этих векторов

В общем, обычная векторная жизнь.
### Формат ввода:
В двух строках входного файла заданы по четыре целых числа, не превосходящих по модулю 10 000, — координаты начала и конца первого вектора, затем второго.
### Формат вывода:
В каждой строке выходного файла — ответ на соответствующий пункт задачи с точностью не менее 10<sup>-6</sup>.
## [B. Две прямые](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/B.cpp)
Даны коэффициенты A<sub>1</sub>, B<sub>1</sub>, C<sub>1</sub> уравнения первой прямой и коэффициенты A<sub>2</sub>, B<sub>2</sub>, C<sub>2</sub> уравнения второй прямой. Требуется:  
* Построить направляющие векторы для обеих прямых (вывести координаты)  
* Найти точку пересечения двух прямых или вычислить расстояние между ними, если они параллельны
### Формат ввода:
В первой строке входного файла находятся три числа — коэффициенты нормального уравнения для первой прямой. Во второй строке — коэффициенты для второй прямой.  
Все числа во входном файле по модулю не превосодят 10 000.
### Формат вывода:
В каждой строке выходного файла — ответ на соответствующий пункт задачи с точностью не менее 10<sup>-6</sup>.
## [C. Точка и две точки](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/C.cpp)
Определите, принадлежит ли точка C заданной прямой, лучу и отрезку, образованными точками A и B.  
Задумайтесь принадлежит ли вам ваша жизнь.
### Формат ввода:
В первой строке входного файла даны два целых числа — координаты точки C. Во двух следующих строках в таком же формате заданы точки A и B (A ≠ B).  
Все числа во входном файле по модулю не превосодят 10 000.
### Формат вывода:
В первой строке выведите «YES», если точка C принадлежит прямой AB, и «NO» в противном случае. Во второй и третьей строках аналогично выведите ответы для луча AB (A — начало луча) и отрезка AB.
## [D. Расстояния](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/D.cpp)
Даны три точки A, B и C. Необходимо подсчитать расстояния от точки C до прямой, луча и отрезка, образованного точками A и B.
### Формат ввода:
В первой строке входного файла даны два целых числа — координаты точки C. Во двух следующих строках в таком же формате заданы точки A и B (A ≠ B).  
Все числа во входном файле по модулю не превосодят 10 000.
### Формат вывода:
В первой строке выходного файла выведите одно вещественное число — расстояние от точки C до прямой. В следующих двух строках выведите соответственно расстояния до луча AB (A — начало луча) и до отрезка AB. Все числа выводить с точностью не менее 10<sup>-6</sup>. Луч строится по направлению от точки A к точке B.
## [E. Два отрезка](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/E.cpp)
Необходимо проверить, пересекаются ли два отрезка.
### Формат ввода:
В двух строках входного файла заданы по четыре целых числа, не превосходящих по модулю 10 000, — координаты концов первого отрезка, затем второго.
### Формат вывода:
В первой строке выходного файла выведите «YES», если отрезки имеют общие точки, и «NO» в противном случае.
## [F. Отрезки на дистанции](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/F.cpp)
Найдите расстояние между двумя отрезками.
### Формат ввода:
В двух строках входного файла даны по четыре целых числа, не превосходящих по модулю 10 000, — координаты концов сначала первого, затем второго отрезков.
### Формат вывода:
В первой строке выходного файла выведите одно вещественное число — расстояние между отрезками с точностью не менее 10<sup>-6</sup>.
## [G. (Не)выпуклый](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/G.cpp)
Проверьте многоугольник на выпуклость. Задумайтесь над тем, что в 1863 году слово "впуклый" использовалось наравне с словом "выпуклый", но за следующие двести лет сокрушительно проиграло конкуренцию букве "ы".
### Формат ввода:
В первой строке одно число N (3 ≤ N ≤ 100000). Далее в N строках по паре целых чисел — координаты очередной вершины простого многоугольника в порядке обхода по или против часовой стрелки.
Координаты всех точек целые, по модулю не превосходят 10<sup>7</sup>.
### Формат вывода:
Одна строка «YES», если приведённый многоугольник является выпуклым, и «NO» в противном случае.
## [H. Внутри или нет?](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/H.cpp)
Проверьте, лежит ли точка внутри многоугольника.
### Формат ввода:
В первой строке вводятся три целых числа – N (3 ≤ N ≤ 100000) и координаты точки.  
Далее в N строках задается по паре целых чисел – координаты очередной вершины простого многоугольника в порядке обхода по или против часовой стрелки.
### Формат вывода:
Выведите одну строку: «YES», если заданная точка содержится в приведённом многоугольнике или на его границе, и «NO» в противном случае.
## [I. Площадь](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/I.cpp)
Ежегодно в Бостоне совершается более 300 ограблений банков. Большинство этих профессионалов живут в районе с площадью в всего S квадратных миль под названием Чарльзтаун. Найдите эту площадь.
### Формат ввода:
В первой строке одно число N (3 ≤ N ≤ 100 000). Далее в N строках по паре чисел — координаты очередной вершины простого многоугольника в порядке обхода по или против часовой стрелки.  
Координаты целые, по модулю не превосходящие 10<sup>18</sup>.
### Формат вывода:
Одно число — величина площади приведённого многоугольника с точностью 1 знак после запятой.
## [J. Geometry](https://github.com/PlatonYadrov/Second_semester/tree/main/Algorithms/First_contest/Geometry)
В этой задаче необходимо реализовать набор классов для решения геометрических задач на плоскости. Все координаты предполагаются целочисленными.  
`Vector`  
Реализовать класс `Vector` для вектора на плоскости с необходимыми арифметическими операциями (унарные и бинарные `+/-`, умножение/деление на скаляр, присваивающие версии операций, сравнение на равенство).  
`Shape`  
Создать набор классов-фигур, которые наследуются от абстрактного базового класса `IShape` для работы с двумерными геометрическими примитивами:  
•	`Point` (точка);  
•	`Segment` (отрезок);  
•	`Line` (линия);  
•	`Ray` (луч);  
•	`Polygon` (простой многоугольник - часть плоскости, ограниченная замкнутой ломаной без самопересечений);  
•	`Circle` (окружность).  
В базовом классе `IShape` предусмотреть чисто виртуальные методы:  
•	`Move(const Vector&)` - сдвига на заданный вектор, метод должен изменять состояние объекта и возвращать ссылку на сам объект;  
•	`ContainsPoint(const Point&)` - проверка `(true/false)` содержит ли фигура (внутренность фигуры) точку;  
•	`CrossesSegment(const Segment&)` проверка (`true/false`) пересекается ли фигура (граница фигуры) с отрезком;  
•	`Clone()` - копирование объекта (необходимо вернуть умный или обычный указатель на копию фигуры);  
•	`ToString()` - строковое представление фигуры (формат см. в примерах).  
В производных классах - реализовать эти методы. Разность двух точек должна возвращать вектор перемещения одной точки в другую.  
Детали  
Все классы должны располагаться в пространстве имен geometry.  
С публичным интерфейсом классов, который используется в задаче, подробнее можно ознакомиться в файле `geometry_main.cpp`. В частности, Point должен уметь конструироваться от двух целых чисел, `Segment`, `Line` и `Ray` - от двух `Point`, многоугольник - от `std::vector<Point>`, окружность - от центра (`Point`) и радиуса (`int`).  
Объявления классов расположите в соответствующих .h файлах, а необходимые файлы реализации положите в папку `src`. После этого вы можете запустить `geometry_public_test` (по обычной инструкции - через терминал, либо с помощью IDE) и протестировать на различных входных данных. Вы можете прочитать, что принимает программа на вход из файла `geometry_main.cpp` и найти примеры корректной работы на странице задачи в контесте.  
__Где ошибка? Тесты:__  
•	1-6 совпадают с примером  
•	7-15 _Point_  
•	16-46 _Segment_  
•	47-55 _Ray_  
•	56-60 _Line_  
•	61-71 _Polygon_  
•	72-80 _Circle_  
### Формат ввода:
В первой строчке задается тип геометрического примитива: _point_, _segment_, _ray_, _line_, _circle_ или _polygon_. Далее вводится сам примитив.
После чего вводится две точки A и B, которые используются в CheckFunctionsCheckFunctions. Все числа целочисленные и не превосходят 10000 по модулю.
Для Point выводятся ее координаты; Segment - два конца (точки); Ray - начало (точка) и направляющий вектор; Line - коэффициенты уравнения прямой (ax + by + c) с точностью до некоторого множителя (по идее система должна принимать и Line(1, −1, 1), и Line(−2, 2, −2)); Polygon - последовательность вершин; Circle - центр и радиус.
## [K. Выпуклая оболочка](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/K.cpp)
Дано N точек на плоскости. Нужно построить их выпуклую оболочку, используя алгоритм Грэхема.  
Гарантируется, что выпуклая оболочка не вырождена.
### Формат ввода:
На первой строке число N (3 ≤ N ≤ 10<sup>5</sup>). Следующие N строк содержат пары целых чисел x и y (-10<sup>9</sup> ≤ x, y ≤ 10<sup>9</sup>) — точки.  
Будьте аккуратны! Точки произвольны. Бывают совпадающие, бывают лежащие на одной прямой в большом количестве.
### Формат вывода:
В первой строке выведите K — число вершин выпуклой оболочки. Следующие K строк должны содержать координаты вершин в порядке обхода. Никакие три подряд идущие точки не должны лежать на одной прямой.  
Кроме того, в последней строке выведите площадь получившейся выпуклой оболочки. Площадь необходимо вывести c точностью 1 знак после запятой.
## [L. Выпуклая оболочка. Возвращение легенды](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/L.cpp)
Дано N точек на плоскости. Нужно построить их выпуклую оболочку. Всё то же самое, но по-другому. В этот раз реализуйте алгоритм Джарвиса.  
Гарантируется, что выпуклая оболочка не вырождена.
### Формат ввода:
На первой строке число N (3 ≤ N ≤ 10<sup>5</sup>). Следующие N строк содержат пары целых чисел x и y (-10<sup>9</sup> ≤ x, y ≤ 10<sup>9</sup>) — точки.  
Будьте аккуратны! Точки произвольны. Бывают совпадающие, бывают лежащие на одной прямой в большом количестве.
### Формат вывода:
В первой строке выведите K — число вершин выпуклой оболочки. Следующие K строк должны содержать координаты вершин в порядке обхода. Никакие три подряд идущие точки не должны лежать на одной прямой.  
Кроме того, в последней строке выведите площадь получившейся выпуклой оболочки. Площадь необходимо вывести c точностью 1 знак после запятой.
## [M. Инфекция](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/M.cpp)
Неизвестная инфекция начала распространяться по всей столице. Известно, что она распространяется почти одинаково во все стороны, поэтому было решено разбить город на зоны, чтобы лучше мобилизовать ресурсы в случае внештатной ситуации.  
Студент Артур долго работал над такой моделью и выяснил, что лучше всего разбить город следующим образом. Задано множество точек размера N — социально значимых объектов в столице. По этому множеству точек разбиение строится так:  
1.	строится выпуклая оболочка на этом множестве, потом все точки, что в нее попали (или на ее границу) выбрасываются.  
2.	повторяют первый шаг, пока не останется два или меньше социально значимых объектов.

То есть по индукции построили множество выпуклых оболочек. Точка лежит в зоне с номером i, если она лежит внутри i-й оболочки и не лежит внутри (i + 1)-й оболочки. Точка лежит в оболочке, если попадает на ее границу или лежит внутри. Зоны нумеруются с нуля, так как там еще нет инфекции.  
Ученые заинтересовались его исследованием и решили, что это действительно хорошая модель разбиения, так как точки подобраны согласно последним данным о распространении инфекции. Теперь им стало интересно, в какой зоне будут лежать научно важные объекты, например, университеты или лаборатории. Всего таких объектов K, а так как таких объектов очень много, ученые попросили автоматизировать процесс. Справитесь ли вы с этим поручением?  
### Формат ввода:
В первой строке вам дается число N (3 ≤ N ≤ 10<sup>3</sup>) — количество социально значимых объектов для разбиения города на зоны.  
Далее идут N строк по два целых числа через пробел (x<sub>i</sub>, y<sub>i</sub>) (-10<sup>9</sup> ≤ x<sub>i</sub>, y<sub>i</sub> ≤ 10<sup>9</sup>) — координаты очередного социально значимого объекта. Гарантируется, что одинаковых точек нет. Считайте, что точки, лежащие снаружи нулевой оболочки лежат в нулевой зоне.
На следующей строке идет число K (1 ≤ K ≤ 10<sup>9</sup>) — количество научно значимых объектов, про которые ученым надо знать их зону.
Далее идут K строк по два целых числа через пробел (x<sub>i</sub>, y<sub>i</sub>) (-10<sup>9</sup> ≤ x<sub>i</sub>, y<sub>i</sub> ≤ 10<sup>9</sup>) — координаты университетов, лабораторий …
### Формат вывода:
Выведите K строк из одного целого числа, где на i-й строке номер зоны i-го научно значимого объекта.
## [N. Радио](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/First_contest/N.cpp)
Компания «Аудио Квадрат» захватила значительную долю рынка музыкальных товаров и услуг. В частности она делает персональное радио для каждого человека, которое учитывает его музыкальные предпочтения и текущее настроение.

Но параллельно, just for fun, компания запускает проект общественного радио. Это радио, в котором песня выбирается в соответствии с пожеланиями множества проголосовавших пользователей.

Алгоритм общественного радио безумно прост. Посетители интернет сайта «Аудио Квадрата» постоянно голосуют за отдельные композиции (с одного IP можно проголосовать в течении 10 минут только за одну композицию). Голос может иметь вес score. Для каждой композиции считаются очки — track_score. Следующей композицией, которая будет играть на радио, станет та, которая имеет максимальное количество очков. Если таких композиций несколько, то должна играть та, которая имеет минимальный идентификатор. В момент, когда композиция запускается на радио, её track_score становится равным -1.

Чтобы исключить попытки накручивания счётчика определёнными группами лиц, компания решила принимать голоса с одного IP не чаще раза в 10 минут (два голоса могут быть приняты, если между ними не менее шестисот секунд).

Вы являетесь главным разработчиком компании «Аудио Квадрат». И хотя у вас в подчинении множество высококлассных программистов, вы решили вспомнить старые добрые времена и запрограммировать этот алгоритм сами.

Общественных радио будет много, поэтому важно, чтобы каждое из них работало достаточно эффективно, то есть не отнимало много процессорных ресурсов и оперативной памяти.

Необходимо написать программу, реализующую алгоритм работы одного общественного радио. Взаимодействие с программой будет осуществляться через стандартный поток ввода/вывода согласно заданному ниже протоколу.

Для решения этой задачи используйте ассоциативные контейнеры и очереди с приоритетами.
### Формат ввода:
Каждая строчка входа — это определенная команда. Всего 3 типа команд:  
•	VOTE ip track_id score time  
•	GET  
•	EXIT  
Команда V OT E меняет число очков track_score определённой композиции. Она получает четыре аргумента:  
• ip — IP адрес компьютера, с которого пришел голос; четыре целых числа из промежутка [0, 255], разделённых точкой  
• track_id — численный идентификатор композиции; натуральное число из отрезка [1, 2 · 107 ];  
• score — количество очков, которое нужно добавить к текущим очкам композиции track_score — целое число из отрезка [−100, 100];  
• time — момент времени в секундах от некоторого фиксированного момента времени — целое число из промежутка [0, 2 · 109 ].  
На команду VOTE нужно отвечать новым значением очков музыкальной композиции track_id (даже если эти очки не изменились).  
Команда GET используется для получения следующей композиции. Ваша программа должна отвечать на неё парой track_id и track_score (вывести эти два числа в одной строке, разделив их пробелом). Сразу после выполнения этой команды новое значение track_score для этой композиции должно стать равным -1.  
Команда EXIT находится в последней строке входа. При её получении необходимо вывести строку «OK». Число команд на входе не более 100001. Изначально значение track_score для всех композиций равно 0.  
Команды во входных данных упорядочены по параметру time (для двух из трёх команд этот параметр просто не передаётся, так как не нужен).
### Формат вывода:
Выход должен содержать ровно столько же строчек, что и вход. Каждая строчка выхода — это ответ на соответствующую команду из входа.
# [Cpp First_contest](https://github.com/PlatonYadrov/Second_semester/tree/main/cpp/First_contest)
## [A. String](https://github.com/PlatonYadrov/Second_semester/tree/main/cpp/First_contest/string)
_В качестве решения ожидается zip архив с решением (даже если решение состоит из одного файла). Присылайте файлы только с ВАШИМ кодом, то есть файлы с тестами и CMakeLists.txt присылать не нужно._  
### Условие
Напишем класс динамической саморасширяющейся строки, заодно познакомимся со стандартным классом `std::string`.

`std::string`
Класс `std::string` предоставляет удобный и безопасный интерфейс работы со строками в `C++`. Одна из главных проблем стековых и выделяемых в куче строк (массивов char) заключается в том, что они имеют фиксированный размер и не умеют автоматически расширяться при необходимости. При создании строк в динамической области возникает потребность в ручном отслеживании возможных утечек памяти, что накладывает дополнительные сложности на процесс разработки. Кроме того, `C-style` строки не хранят информацию о своем размере, что тоже не упрощает взаимодействие с ними.  

Эти проблемы можно обойти, используя ООП функционал `C++`. В частности, механизм инкапсуляции позволяет хранить размер строки в отдельном поле, реализовать методы, при вызове которых массив будет автоматически расширяться, создавая иллюзию неограниченной строки, а механизмы работы с ресурсами гарантируют своевременное выделение и очищение памяти.  

#### Пример:

`std::string s = "hello"`;  
`s.Size()`;        // 5, работает за O(1)  
`s[0] = 'H'`;  
`s += ", world!"`  // строка расширяется  
`std::cout << s`;  // "Hello, world!"  
Подробнее о возможностях `std::string` [здесь](https://en.cppreference.com/w/cpp/string/basic_string).

### Задание
Реализуйте класс динамической строки - аналог std::string, с эффективной стратегией расширения (мультипликативная схема).

Введем понятия "размера" строки (`size`) и ее "вместимости" (`capacity`). `С++` в каждый момент времени позволяет поддерживать массивы конечной вместимости (сколько выделено памяти), при этом фактический размер (количество реально используемых символов) может быть меньше этого значения. Почему бы постоянно не поддерживать равенство между этими величинами? - Это не эффективно. Допустим, мы добавляем символы в конец строки по одному. Тогда при каждом обновлении будет происходить перевыделение исходной памяти с последующим копированием всех старых элементов в новый буфер. Легко видеть, что в этом случае общее число копирований будет квадратичным образом зависеть от числа добавленных элементов. Оказывается, что, если при каждом переполнении массива увеличивать его вместимость в константное число раз, то можно добиться линейной зависимости числа операций над массивом от числа добавляемых элементов. В вашем решении будет проверяться корректность работы данной схемы при множителе равном 2 (то есть, при переполнении буфера его вместимость должна увеличиваться __минимум в 2 раза__).

### Детали реализации
Реализуйте класс String со следующим интерфейсом:  
*	Конструктор по умолчанию - создает пустую строку (`nullptr`);
*	Конструктор, принимающий `size` и `symbol`, - создает строку длины `size`, заполненную символами `symbol`.
*	Конструктор, принимающий `С-style` строку (`const char*`) и создающий на ее основе строку. Этот конструктор должен уметь выполнять неявные преобразования, поэтому не нужно объявлять его `explicit`. Это не понравится кодстайл чекеру, поэтому к строке с объявлением добавьте комментарий `// NOLINT`, чтобы он проигнорировал эту строку.  
*	Конструктор, принимающий массив `char` (`const char*`) и количество первых символов (`size`), которые нужно скопировать.  
*	Правило "трех".  
*	Константный и неконстантный оператор доступа по индексу `[]`. Последний должен позволять изменять полученный символ (`s[0] = 'H'`);  
*	Константный и неконстантный метод доступа по индексу `At`. При выходе за границы строки должен бросать исключение `StringOutOfRange`, которое написано за вас (об этом ниже).  
*	Методы `Front()` и `Back()`
    * доступ к первому и последнему символам (тоже по две версии).

*	Методы `CStr()` и `Data()`  
    * возвращают указатель на начало строки (`C-style` строку).  
*	Метод `Empty()`  
    * `true`, если строка пуста (размер 0).  
*	Методы `Size()` и `Length()`  
    * размер строки.  
*	Метод `Capacity()`  
    * текущая вместимость.  
*	Метод `Clear()`  
    * устанавливает размер в 0, удаления выделенной памяти при этом НЕ происходит.  
*	Метод `Swap(other)`  
    * обменивает содержимое с другой строкой `other`.  
*	Метод `PopBack()`  
    * удаляет последний символ.  
* Метод `PushBack(symbol)`  
    * добавляет символ symbol в конец строки (при необходимости строка расширяется).  
*	Операция `+=`  
    * принимает другую строку (`String`) и приписывает ее в конец текущей.  
*	Метод `Resize(new_size, symbol)`  
   	* изменяет размер на `new_size`. Если вместимость не позволяет хранить столько символов, то выделяется новый буфер с вместимостью `new_size`. В случае `new_size > size` заполняет недостающие символы значением `symbol`.  
*	Метод `Reserve(new_capacity)`  
    * изменяет вместимость на `max(new_capacity, текущая вместимость)`. Размер при этом не изменяется.  
*	Метод `ShrinkToFit()`  
    * уменьшает `capacity` до `size` (убирает излишек).  
*	Конкатенация с помощью операции `+`.  
*	Операции сравнения `(<, >, <=, >=, ==, !=)`, задающие лексикографический порядок.  
*	Операция вывода в поток.  
#### Замечания.
1.	Решение должно состоять из файлов `cppstring.h` и `cppstring.cpp`.  
2.	В этой задаче запрещается использование стандартной библиотеки `C++`. Если нужны какие-либо служебные классы или функции, реализуйте их самостоятельно.
3.	Проверка устроена таким образом, что требует от вас жесткого следования принятым (выше) сигнатурам и именованиям сущностей (то есть никакие `MyString`, `__string_`, `push_back`, `superSolver3000` не пройдут). Если вы реализовали требуемый функционал не полностью или интерфейс отличается от заявленного, вы получите ошибку компиляции.
4.	В тесты включены проверки функциональности (методы работают так как требует условие), проверка эффективности реализации (что значит эффективно описано выше), проверка корректности работы с памятью (утечки памяти, обращения к памяти не принадлежащей процессу будут приводить к провалу).
5.	"Бросить исключение типа E" значит - написать строку `throw E{}`;. В этот момент выполнение функции прекращается и, если исключение не будет обработано, программа завершится аварийно. Тестирующий код корректно обработает эту ошибку, вам этого делать не нужно.
## [B. UniquePtr](https://github.com/PlatonYadrov/Second_semester/blob/main/cpp/First_contest/B.h)
### Условие
_С++ предоставляет шаблонный класс std::unique_ptr (https://en.cppreference.com/w/cpp/memory/unique_ptr) для безопасной работы с динамически выделенной памятью (и другими ресурсами). В std::unique_ptr перегружены все необходимые операции для комфортной работы с объектами так, как если бы это были обычные указатели (которые еще память за собой очищают). Объекты этого класса считаются единственными владельцами ресурса, на который они указывают, поэтому эти объекты нельзя копировать, но можно перемещать - передавать владение другому объекту. Использование std::unique_ptr почти не накладывает дополнительных вычислительных расходов, поэтому пользоваться им так же эффективно, как и обычными указателями, и при этом гораздо безопаснее._  
#### Пример:
```
#include <memory>

// ...

std::unique_ptr<int> ptr(new int(10));

std::cout << *ptr << '\n';  // 10

// std::unique_ptr<int> copy = ptr; копирование запрещено

std::unique_ptr<int> moved = std::move(ptr);  // теперь ptr пуст

std::cout << *moved << '\n';  // 10

auto rational = std::make_unique<Rational>(1, 2);

// эквивалентно std::unique_ptr<Rational> rational(new Rational(1, 2));

std::cout << rational->Numerator() << ' ' << rational->Denominator() << '\n';  // 1 2

// delete вызовутся автоматически в деструкторах!
```
#### Задание
Реализуйте шаблон `UniquePtr` - упрощенный аналог класса умного указателя с уникальным владением, `std::unique_ptr (C++11)`.  
### Детали реализации
Шаблонный класс должен поддерживать:  
•	Конструктор по умолчанию (создает нулевой указатель).  
•	Конструктор от указателя (сохраняет указатель на объект).  
•	Конструктор копирования и копирующее присваивание должны отсутствовать.  
•	Перемещающий конструктор и перемещающее присваивание должны передавать владение объектом.  
•	Метод `Release()`, который отлучает класс от владения текущим ресурсом и возвращает указатель на него.  
•	Метод `Reset(T* ptr = nullptr)`, меняет указатель, которым владеет объект (старый ресурс удаляется).  
•	Метод `Swap(UniquePtr<T>&)`.  
•	Метод `Get()`, возвращающий указатель на объект.  
•	Оператор разыменовывания `operator*`.  
•	Оператор "стрелочка" `operator->`.  
•	Явный оператор приведения к `bool (operator bool)`.  
#### Замечания.
•	https://en.cppreference.com/w/cpp/memory/unique_ptr  
•	Решение должно состоять из одного файла `unique_ptr.h`
## [C. SharedPtr](https://github.com/PlatonYadrov/Second_semester/blob/main/cpp/First_contest/C.h)
_Умные указатели реализуют важную идиому C++ - RAII (Resource Acquisition Is Initialization) и позволяют не заботиться о ручном управлении памятью, так как инкапсулируют управление ресурсами посредством конструкторов и деструкторов._

`std::shared_ptr (C++11)`  
Шаблонный класс `std::shared_ptr` предоставляет интерфейс указателя на данные в динамической области с автоматическим контролем своевременного выделения и удаления ресурсов. В отличие от `std::unique_ptr`, `std::shared_ptr` реализует семантику разделяемого владения ресурсом, что означает, что у одного ресурса может быть несколько равноправных владельцев. При этом гарантируется, что ресурс не будет освобожден пока существует хотя бы один его владелец (хотя бы один объект `std::shared_ptr` указывает на ресурс). Для решения проблемы циклических ссылок в язык также введены "слабые указатели" `std::weak_ptr`, которые не считаются полноценными владельцами ресурса, но из них при необходимости можно получить "сильный указатель" `std::shared_ptr` на объект, если тот еще не удален.  

Несмотря на то, что `std::shared_ptr` удобнее в использовании чем `std::unique_ptr`, на практике последний работает гораздо эффективней - `std::shared_ptr` реализует дополнительную логику с подсчетом ссылок на объект. Поэтому `std::shared_ptr` стоит использовать только тогда, когда вам действительно нужно разделяемое владение.
#### Задание
Реализуйте шаблон SharedPtr - упрощенный аналог класса умного указателя с разделяемым владением.

Идея реализации: помимо самого указателя на выделенный ресурс необходимо знать число "сильных" и "слабых" ссылок на объект. Для этого в куче выделим специальную счетчик strong_counter, который будет хранить эту информацию (при создании нового указателя соответствующий счетчик увеличивается, при удалении - уменьшается; если число сильных ссылок стало равно 0, то объект удаляется).
### Детали реализации
Детали обсуждались на лекции и семинарах. Шаблонный класс `SharedPtr` должен поддерживать:  
•	Конструктор по умолчанию (создает нулевой указатель).  
•	Конструктор от указателя (сохраняет указатель на владеемый объект).  
•	Конструктор копирования и копирующее присваивание (создают новую ссылку на тот же объект).  
•	Перемещающий конструктор и перемещающее присваивание должны передавать владение объектом.  
•	Метод `Reset(T* ptr = nullptr)`, меняет указатель, которым владеет объект.  
•	Метод `Swap(SharedPtr<T>&)`.  
•	Метод `Get()`, возвращающий указатель на владеемый объект.  
•	Метод `UseCount()`, возвращающий число "сильных" ссылок на объект.  
•	Оператор разыменовывания `operator*`.  
•	Оператор "стрелочка" `operator->`.  
•	Явный оператор приведения к `bool (operator bool)`.
#### Замечания.
•	https://en.cppreference.com/w/cpp/memory/shared_ptr  
•	Решение должно состоять из одного файла `shared_ptr.h`
## [F. Calculator.Tokenize](https://github.com/PlatonYadrov/Second_semester/tree/main/cpp/First_contest/Tokenize)
_Когда говорят "компьютерная программа", одно из первых, что приходит на ум, - калькулятор. Действительно, изначальное назначение компьютеров - производить математические вычисления. И кажется, это настолько базовая задача, что написать калькулятор на любом известном вам языке программирования не составляет никакого труда. Тем не менее оказывается, что это не такая уж тривиальная и скучная задача. Как, например, вычислить значение, заданное входом "1 * (((2 * 3) * (4 + 5) + 6 + 7) * (8 * 9 + 10 * 11) * 12)"? Данная задача в трех частях ответит на этот вопрос._
### Tokenize
Первым шагом практически в любой задаче, работающей с пользовательским вводом, является токенизация - разбиение исходного текста на отдельные смысловые части (например, фразы, слова, буквы). В нашей задаче в качестве токенов будут выступать математические символы.

Всего рассмотрим 13 типов токенов: `"+" (PlusToken), "-" (MinusToken), "*" (MultiplyToken), "/" (DivideToken), "%" (ResidualToken), "(" (OpeningBracketToken), ")" (ClosingBracketToken), "sqr" (SqrToken), "max" (MaxToken), "min" (MinToken), "abs" (AbsToken), "23" (NumberToken, здесь произвольное число), "abracadabra" (UnknownToken)`.

Для каждого типа токена необходимо завести свою структуру (название написано в скобках). Все структуры могут быть пустыми, за исключением `NumberToken`, который дополнительно в `int` поле value должен хранить значение числа, и `UnknownToken`, который в строковом поле `value` должен хранить значение неизвестного токена.

Чтобы хранить все токены в одном контейнере необходимо привести все значения к одному типу. Мы бы могли вновь воспользоваться наследованием и хранить указатель на базовый класс, но в этом задании мы познакомимся с классом `std::variant (C++17)`, который может хранить в себе значение одного из заранее заданных типов (ООП аналог `union`).
#### std::variant (C++17)
https://en.cppreference.com/w/cpp/utility/variant  
`std::variant` - шаблонный класс, который может хранить в себе произвольное значение одного из нескольких указанных в шаблоне типов. Основные функции, которые вам понадобятся:
•	`std::get<T>` принимает тип `T` в качестве параметра шаблона и объект `std::variant` в качестве аргумента. Если тип хранимого в данный момент объекта совпадает с указанным, то возвращается значение, иначе бросается исключение `std::bad_variant_access`;  
•	`std::holds_alternative<T>` проверяет лежит ли в данный момент в объекте значение типа `T` и возвращает `true` или `false` в зависимости от результата;  
•	`operator==` возвращает `true`, если для хранимых объектов совпадают типы и их значения.  
Остальные методы и функции можете найти в документации.
#### Пример:
```
std::variant<int, std::string> v;  // объект может хранить в себе либо int, либо std::string

v = 5;  // сейчас в нем хранится int

if (std::holds_alternative<int>(v)) std::cout << std::get<int>(v);  // на экране "5"

v = std::string("aba");  // теперь хранится std::string

std::get<int>(v);  // бросается исключение (хранится не int)

v = std::array<int, 3>();  // ошибка компиляции (v не может хранить std::array<int, 3>)
```
#### Детали реализации
В файле `tokenize.h` объявите и определите описанные выше структуры и заведите тип `Token`, который может хранить любой тип токена, как псевдоним `std::variant<PlusToken, MinusToken,... (и т.д.)>` (с помощью `using`). Не забудьте определить оператор сравнения на равенство для каждого типа токена, чтобы сравнение двух токенов в тестах работало нормально (для токенов, которые ничего не хранят, сравнение на `==` должно просто возвращать `true`).

Основное задание заключается в написании функции `std::vector<Token> Tokenize(std::string_view)`, которая принимает строку и возвращает последовательность токенов в ней.

Опишите прототип в файле `tokenize.h`, а реализацию и необходимые побочные функции в `tokenize.cpp`.

Для простоты будем считать, что все токены разделены произвольным ненулевым количеством пробелов.
# [Algorithms Second_contest](https://github.com/PlatonYadrov/Second_semester/tree/main/Algorithms/Second_contest)
## [A. Кратчайший путь](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/A.cpp)
Вам дан неориентированный граф. Найдите кратчайший путь от вершины a до вершины b.
### Формат ввода:
В первой строке входного файла идут целые числа n и m (1 ≤ n ≤ 50 000, 1 ≤ m ≤ 100 000) — количества вершин и рёбер соответственно. Во второй строке идут целые числа a и b — стартовая и конечная вершины соответственно. Далее идут m строк, описывающих рёбра.
### Формат вывода:
Если пути между a и b нет, выведите единственное число -1. Иначе выведите в первой строке число l — длину кратчайшего пути между этими двумя вершинами в рёбрах, а во второй строке выведите l + 1 число — вершины этого пути.
## [B. Нет списыванию](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/B.cpp)
Во время контрольной работы профессор Флойд заметил, что некоторые студенты обмениваются записками. Сначала он хотел поставить им всем двойки, но в тот день профессор был добрым, а потому решил разделить студентов на две группы: списывающих и дающих списывать, и поставить двойки только первым.  
У профессора записаны все пары студентов, обменявшихся записками. Требуется определить, сможет ли он разделить студентов на две группы так, чтобы любой обмен записками осуществлялся от студента одной группы студенту другой группы.
### Формат ввода:
В первой строке находятся два числа N и M — количество студентов и количество пар студентов, обменивающихся записками (1 ≤ N ≤ 100, 0 ≤ M ≤ N ⋅ (N - 1) / 2). Далее в M строках расположены описания пар студентов: два числа, соответствующие номерам студентов, обменивающихся записками (нумерация студентов идёт с 1). Каждая пара студентов перечислена не более одного раза.
### Формат вывода:
Необходимо вывести ответ на задачу профессора Флойда. Если возможно разделить студентов на две группы — выведите YES; иначе выведите NO.
## [C. Очередная задача с ЕГЭ](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/C.cpp)
Витя хочет придумать новую игру с числами. В этой игре от игроков требуется преобразовывать четырехзначные числа не содержащие нулей при помощи следующего разрешенного набора действий:  
1.	Можно увеличить первую цифру числа на 1, если она не равна 9.  
2.	Можно уменьшить последнюю цифру на 1, если она не равна 1.  
3.	Можно циклически сдвинуть все цифры на одну вправо.  
4.	Можно циклически сдвинуть все цифры на одну влево.

Например, применяя эти правила к числу 1234 можно получить числа 2234, 1233, 4123 и 2341 соответственно. Точные правила игры Витя пока не придумал, но пока его интересует вопрос, как получить из одного числа другое за минимальное количество операций.
### Формат ввода:
Во входном файле содержится два различных четырехзначных числа, каждое из которых не содержит нулей.
### Формат вывода:
В первой строке вывода должна быть длина оптимальной последовательности чисел, которая описана ниже.  
На второй строке необходимо вывести последовательность четырехзначных чисел, не содержащих нулей. Последовательность должна начинаться первым из данных чисел и заканчиваться вторым из данных чисел, каждое последующее число в последовательности должно быть получено из предыдущего числа применением одного из правил. Количество чисел в последовательности должно быть минимально возможным.
## [D. Найти саб](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/D.cpp)
В славном городе Нью-Йорке в не менее славном районе Манхэттен на некоторых перекрестках установлены рестораны сети Subway. Также в этом районе на каждом перекрестке установлены офисные здания.  
Для упрощения дел, будем считать Манхэттен районом, где все дороги идут перпендикулярно, а сам он имеет вид прямоугольника размера N × M перекрестков. Расстояние между клетками с координатами (x<sub>1</sub>, y<sub>1</sub>), (x<sub>2</sub>, y<sub>2</sub>) равно числу участков дорог, которые надо проехать (или |x<sub>1</sub> - x<sub>2</sub>| + |y<sub>1</sub> - y<sub>2</sub>|).  
Нужно по расположению ресторанов Subway узнать для каждого перекрестка минимальное расстояние от него до одного из ресторанов. Гарантируется, что хотя бы один ресторан имеется в Манхэттене.
### Формат ввода:
В первой строке вводятся два натуральных числа N и M, не превосходящих 1000 — размеры Манхэттена. Далее идут N строк по M чисел — карта перекрестков района, где 1 означает наличие ресторана на этом перекрестке, и 0 — его отсутствие.
### Формат вывода:
Требуется вывести N строк по M чисел, где для каждого перекрестка указано расстояние до ближайшего Саба.
## [E. Найти минимальный путь](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/E.cpp)
Дан ориентированный взвешенный граф. Найдите кратчайшее расстояние от одной заданной вершины до другой.
### Формат ввода:
В первой строке входного файла два числа: N и M (1 ≤ N ≤ 100, 0 ≤ M ≤ 10000), где N — количество вершин графа, а M — количество ребер.  
В следующей строке заданы числа S и F — начальная и конечная вершины.  
Далее следует M троек чисел A<sub>i</sub>, B<sub>i</sub>, T<sub>i</sub> (1 ≤ T<sub>i</sub> ≤ 10) — номера вершин соединенных ребром и вес данного ребра.
### Формат вывода:
Вывести искомое расстояние или -1, если пути между указанными вершинами не существует.
## [F. ПДД](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/F.cpp)
В столице одной небольшой страны очень сложная ситуация. Многокилометровые пробки буквально парализовали движение в городе, и власти на многих улицах ввели одностороннее движение, не анализируя, можно ли будет теперь проехать из любого места в городе в любое другое, не нарушая правила. Транспортная система столицы представляет собой N площадей, соединенных M полосами для движения, в том числе круговыми полосами, проходящими по площади. Каждая полоса предназначена для движения только в одну определенную сторону. При этом на магистралях есть полосы, направленные как в одну, так и в другую сторону. По круговой полосе можно двигаться только внутри площади и только против часовой стрелки.

Власти города на каждой полосе разместили видеокамеру, поэтому если Иннокентий едет по встречной полосе (при ее наличии) или, в случае одностороннего движения, в сторону противоположную предписанной знаками, то после поездки против правил по каждой из полос ему придется заплатить штраф в размере одной тысячи тугриков этой страны.

Иннокентий, который торопится купить кафельную плитку со скидкой, решился доехать до магазина в любом случае, даже если для этого придется нарушать правила. Но он хочет выбрать такой маршрут движения, суммарный штраф на котором минимален.

Иннокентий еще не решил, откуда именно и в какой магазин он собирается ехать, поэтому ему необходимо ответить на несколько вопросов вида «Какой минимальный штраф надо заплатить, чтобы добраться из пункта A в пункт B?». Отвечая на потребности жителей столицы, известная поисковая система Индекс разрабатывает соответствующий сервис.

Так как многие из вас рано или поздно будут проходить собеседование на работу в эту фирму, продемонстрируйте, что вы тоже умеете решать эту задачу.
### Формат ввода:
В первой строке входных данных содержатся два числа N и M — количество площадей и полос движения в городе соответственно (1 ≤ N ≤ 5000, 1 ≤ M ≤ 10 000). Далее содержатся описания полос, по которым движение разрешено. Каждая полоса описывается номерами двух площадей, которые она соединяет. Движение разрешено в направлении от первой из указанных площадей ко второй.  
В следующей строке содержится одно число K — количество вопросов у Иннокентия (1 ≤ K ≤ 10 000, N ⋅ K ≤ 2 ⋅ 10<sup>7</sup>). В следующих строках описываются вопросы, каждый вопрос описывается номерами двух площадей, между которыми требуется найти самый дешевый путь. Путь необходимо проложить от первой из указанных площадей ко второй.
### Формат вывода:
Для каждого вопроса выведите одно число — искомый минимальный размер штрафа в тысячах тугриков. В случае, если пути между выбранной парой площадей не существует, выведите - 1.
## [G. Найти цикл](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/G.cpp)
Дан ориентированный невзвешенный граф. Необходимо определить есть ли в нём циклы, и если есть, то вывести любой из них.
### Формат ввода:
В первой строке входного файла находятся два натуральных числа N и M (1 ≤ N ≤ 100000, M ≤ 100000) — количество вершин и рёбер в графе соответственно. Далее в M строках перечислены рёбра графа. Каждое ребро задаётся парой чисел — номерами начальной и конечной вершин соответственно.
### Формат вывода:
Если в графе нет цикла, то вывести NO, иначе — YES и затем перечислить все вершины в порядке обхода цикла.
## [H. Свинки-копилки](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/H.cpp)
У Васи есть N свинок-копилок, свинки занумерованы числами от 1 до N. Каждая копилка может быть открыта единственным соответствующим ей ключом или разбита.

Вася положил ключи в некоторые из копилок (он помнит, какой ключ лежит в какой из копилок). Теперь Вася собрался купить машину, а для этого ему нужно достать деньги из всех копилок. При этом он хочет разбить как можно меньшее количество копилок (ведь ему еще нужно копить деньги на квартиру, дачу, вертолет...). Помогите Васе определить, какое минимальное количество копилок нужно разбить.
### Формат ввода:
В первой строке содержится число N — количество свинок-копилок (1 ≤ N ≤ 100). Далее идет N строк с описанием того, где лежит ключ от какой копилки: в i-ой из этих строк записан номер копилки, в которой находится ключ от i-ой копилки.
### Формат вывода:
Выведите единственное число: минимальное количество копилок, которые необходимо разбить.
## [I. Залетаем в чатики](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/I.cpp)
Вам нужно распространить новость о посвяте среди всех первокурсников. Известно, что первокурсники общаются друг с другом через чаты, при этом если новость вброшена в чат, то гарантируется что все его участники прочтут новость (эх, было бы так не только в условии этой задачи).  
Так как у вас уже и так очень много своих чатов, вы хотите вступить в как можно меньшее их количество, чтобы все первокурсники узнали, что посвят уже скоро. При этом вам неизвестны составы чатов, но до вас дошли сведения, что некоторые пары первокурсников гарантированно сидят в одном чате. Более того, если студент сидит в чате и видит новость, то он пересылает сообщение с важной информации во все остальные чаты, где он есть.
### Формат ввода:
Во входном файле записано два числа N — число первокурсников и M — число известных вам пар первокурсников, сидящих в одном чате (1 ≤ N ≤ 100000, 0 ≤ M ≤ 100000). В следующих M строках записаны по два числа i и j (1 ≤ i, j ≤ N), которые означают, что первокурсники с номерами i и j в одном чате.
### Формат вывода:
В первой строчке выходного файла выведите количество чатов, куда вам надо вступить. Далее выведите группы студентов, которые узнают о новости для каждого вступления в чат: в первой строке количество студентов в такой группе в компоненте, во второй — номера студентов в произвольном порядке.
## [J. Еще одна сортировка](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/J.cpp)
Дан ориентированный невзвешенный граф. Необходимо его топологически отсортировать.
### Формат ввода:
В первой строке входного файла даны два целых числа N и M (1 ≤ N ≤ 100000, 0 ≤ M ≤ 100000) — количества вершин и рёбер в графе соответственно. Далее в M строках перечислены рёбра графа. Каждое ребро задаётся парой чисел - номерами начальной и конечной вершин соответственно.
### Формат вывода:
Вывести любую топологическую сортировку графа в виде последовательности номеров вершин. Если граф невозможно топологически отсортировать, вывести -1.
## [K. Разноцветный граф](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/K.cpp)
Даны N точек, занумерованных числами 1, 2, …, N. От каждой точки с меньшим номером к каждой точке с большим номером ведет стрелка красного или синего цвета. Раскраска стрелок называется однотонной, если нет двух таких точек A и B, что от A до B можно добраться как только по красным стрелкам, так и только по синим.  
Ваша задача — по заданной раскраске определить, является ли она однотонной.
### Формат ввода:
В первой строке входных данных содержится единственное число N (3 ≤ N ≤ 5000).  
В следующих N - 1 строках идет описание раскраски. В (i+1)-й строке записано (N - i) символов R (красный) или B (синий), соответствующих цвету стрелок, выходящих из точки i и входящих в точки (i+1), (i+2), …, N соответственно.
### Формат вывода:
Выведите YES, если приведенная раскраска является однотонной, и NO в противном случае.
## [L. Компоненты сильной связности](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/L.cpp)
Вам задан ориентированный граф с N вершинами и M ребрами (1 ≤ N ≤ 20000, 1 ≤ M ≤ 200000). Найдите компоненты сильной связности заданного графа и топологически отсортируйте его конденсацию.
### Формат ввода:
Граф задан во входном файле следующим образом: первая строка содержит числа N и M. Каждая из следующих M строк содержит описание ребра — два целых числа из диапазона от 1 до N — номера начала и конца ребра.
### Формат вывода:
На первой строке выведите число K — количество компонент сильной связности в заданном графе. На следующей строке выведите N чисел — для каждой вершины выведите номер компоненты сильной связности, которой принадлежит эта вершина. Компоненты сильной связности должны быть занумерованы таким образом, чтобы для любого ребра номер компоненты сильной связности его начала не превышал номера компоненты сильной связности его конца.
## [M. Точки сочленения](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/M.cpp)
Найдите точки сочленения в неориентированном графе.
### Формат ввода:
Первая строка входного файла содержит два натуральных числа n и m — количества вершин и рёбер графа соответственно (1 ≤ n ≤ 20000, 1 ≤ m ≤ 200000).  
Ребро номер i описывается двумя натуральными числами b<sub>i</sub>, e<sub>i</sub> — номерами концов ребра (1 ≤ b<sub>i</sub>, e<sub>i</sub> ≤ n).
### Формат вывода:
Первая строка выходного файла должна содержать одно натуральное число b — количество точек сочленения в заданном графе. На следующих b строках выведите b целых чисел — номера вершин, которые являются точками сочленения, в возрастающем порядке.
## [N. Мосты](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/N.cpp)
Дан неориентированный (быть может несвязный) граф. Требуется найти все мосты в нем.
### Формат ввода:
В первой строке входного файла два натуральных числа n и m (1 ≤ n ≤ 20000, 1 ≤ m ≤ 200000) –количество вершин и рёбер в графе соответственно. Далее в m строках перечислены рёбра графа. Каждое ребро задается парой чисел – номерами начальной и конечной вершин соответственно.
### Формат вывода:
Первая строка выходного файла должна содержать одно натуральное число b – количество мостов в заданном графе. На следующей строке выведите b чисел – номера ребер, которые являются мостами, в возрастающем порядке. Ребра нумеруются с единицы в том порядке, в котором они заданы во входном файле.
## [O. Магнитные подушки](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/O.cpp)
Город будущего застроен небоскребами, для передвижения между которыми и парковки транспорта многие тройки небоскребов соединены треугольной подушкой из однополярных магнитов. Каждая подушка соединяет ровно 3 небоскреба и вид сверху на нее представляет собой треугольник, с вершинами в небоскребах. Это позволяет беспрепятственно передвигаться между соответствующими небоскребами. Подушки можно делать на разных уровнях, поэтому один небоскреб может быть соединен различными подушками с парами других, причем два небоскреба могут соединять несколько подушек (как с разными третьими небоскребами, так и с одинаковым). Например, возможны две подушки на разных уровнях между небоскребами 1, 2 и 3, и, кроме того, магнитная подушка между 1, 2, 5.  
Система магнитных подушек организована так, что с их помощью можно добираться от одного небоскреба, до любого другого в этом городе (с одной подушки на другую можно перемещаться внутри небоскреба), но поддержание каждой из них требует больших затрат энергии.  
Требуется написать программу, которая определит, какие из магнитных подушек нельзя удалять из подушечной системы города, так как удаление даже только этой подушки может привести к тому, что найдутся небоскребы из которых теперь нельзя добраться до некоторых других небоскребов, и жителям станет очень грустно.
### Формат ввода:
В первой строке входного файла находятся числа N и M — количество небоскребов в городе и количество работающих магнитных подушек соответственно (3 ≤ N ≤ 100000, 1 ≤ M ≤ 100000).  
В каждой из следующих M строк через пробел записаны три числа — номера небоскребов, соединенных подушкой. Небоскребы пронумерованы от 1 до N.  
Гарантируется, что имеющиеся воздушные подушки позволяют перемещаться от одного небоскреба до любого другого.
### Формат вывода:
Выведите в выходной файл сначала количество тех магнитных подушек, отключение которых невозможно без нарушения сообщения в городе, а потом их номера.  
Нумерация должна соответствовать тому порядку, в котором подушки перечислены во входном файле. Нумерация начинается с единицы.
## [P. Одностороннее движение](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/P.cpp)
В городе, построенном во времена средневековья, ширина улиц стала препятствовать движению транспорта, которое изначально было двусторонним по каждой из улиц. Для решения этой проблемы было предложено сделать движение по каждой из улиц односторонним. Мэр поручил эту задачу своему первому заму. После долгих размышлений тот доложил, что на некоторых улицах движение придется оставить двусторонним, в противном случае будет невозможно проехать из любого места в городе в любое другое. По данной схеме города требуется найти все такие улицы.
### Формат ввода:
В первой строке входного файла находятся числа N — количество площадей в городе и М — количество улиц их соединяющих (1 ≤ N ≤ 20000, 1 ≤ M ≤ 200000). Площади имеют номера от 1 до N. В каждой из следующих M строк находится пара натуральных чисел, описывающая между какими двумя площадями проходит соответствующая улица (две площади соединяются не более чем одной улицей).
### Формат вывода:
На первой строке выведите число B — количество улиц, на которых организовать одностороннее движение невозможно. На следующей строке выведите B целых чисел — номера этих улиц в возрастающем порядке. Улицы нумеруются с единицы в том порядке, в котором они заданы во входном файле.
## [Q. Автобусные маршруты](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/Q.cpp)
Для решения транспортной проблемы в некотором городе до недавнего времени использовались N автобусных маршрутов. Каждый маршрут начинался на одной из M площадей и там же заканчивался. В процессе проезда по маршруту автобус мог несколько раз проезжать одну и ту же площадь, и даже мог проезжать более одного раза по одной и той же улице в одном и том же направлении. В определенный момент местные власти решили сократить количество автобусных маршрутов в городе до одного. По их мнению, должен был остаться лишь один маршрут, который проходил бы по всем улицам, по которым раньше проходили автобусные маршруты, причем в том же направлении (но не обязательно в том же порядке). Если по каким-либо улицам автобусы ездили в обоих направлениях, то и новый маршрут должен проходить по этим улицам в обоих направлениях. По тем улицам и в тех направлениях, по которым раньше автобусы не ездили, новый маршрут проходить не должен. Однако так как контролеров увольнять нельзя, власти решили, что по каждой улице в каждом направлении новый маршрут должен проходить столько раз, сколько по ней проходили все старые маршруты, вместе взятые. Требуется написать программу, которая для заданных исходных данных определяет требуемый местным властям автобусный маршрут.
### Формат ввода:
Входной файл состоит из следующей последовательности строк. Первая строка содержит число N (N ≤ 10<sup>5</sup>) — количество автобусных маршрутов, M (M ≤ 10<sup>5</sup>) — количество площадей. Каждая из последующих N строк служит для описания соответствующего автобусного маршрута и содержит сначала число k (k ≤ 10<sup>5</sup>), определяющее количество элементов маршрута, а затем k + 1 чисел, задающих номера площадей, которые последовательно проезжает автобус на этом маршруте. Общая длина маршрутов не более 105 улиц. При описании маршрута всегда задаются номера первой и последней площади маршрута, причем они всегда совпадают.
### Формат вывода:
В строку через пробел выведите число площадей в найденном маршруте (стартовая и конечная площади совпадают, но учитываются по отдельности) и саму последовательность площадей. Если организовать требуемый маршрут не удастся, вывод должен содержать одно число - 0.
## [R. Опять ищем минимальный путь](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/R.cpp)
Дан ориентированный взвешенный граф. Найдите кратчайшее расстояние от одной заданной вершины до другой.
### Формат ввода:
В первой строке входного файла два числа: N и M (1 ≤ N ≤ 50 ⋅ 10<sup>3</sup>, 1 ≤ M ≤ 3 ⋅ 10<sup>6</sup>), где N — количество вершин графа, а M — количество ребер.  
В следующей строке заданы числа S и F — начальная и конечная вершины.  
Далее следует M троек чисел A<sub>i</sub>, B<sub>i</sub>, T<sub>i</sub> (1 ≤ T<sub>i</sub> ≤ 30) — номера вершин соединенных ребром и вес данного ребра.
### Формат вывода:
Вывести искомое расстояние или -1, если пути между указанными вершинами не существует.
## [S. Двусвязная атака](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/S.cpp)
Вселенная состоит из планет, между некоторыми есть подходящие для гиперпрыжков гипертоннели (они двусторонние). В ходе битвы с Империей повстанцы выяснили, что Империя может уничтожать некоторые гипертоннели, например, взрывая внутри них астероиды, от чьих обломков нельзя увернуться на таких скоростях.  
Повстанцы знают, что в ходе их атаки Звезде Смерти хватит времени ровно на одно уничтожение гипертоннеля. Поэтому они хотят построить некоторые гипертоннели, чтобы сеть осталась все еще связной после удара Звезды Смерти. Ваша задача — узнать, сколько их надо построить.  
Учитывая то, что система гипертоннелей оптимальна, в ней нет бессмысленных кратных ребер и петель.
### Формат ввода:
Первая строка содержит два числа n (3 ≤ n ≤ 5000) — количество планет и m (1 ≤ m ≤ 100000) — количество построенных гипертоннелей. Следующие m строк содержат два числа v<sub>i</sub>, u<sub>i</sub> (1 ≤ v<sub>i</sub>, u<sub>i</sub> ≤ n) — описание гипертоннелей.
### Формат вывода:
Выведите минимальное количество гипертоннелей, которые нужно достроить, чтобы атака состоялась.
## [U. Алканы](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/U.cpp)
Алканы (также насыщенные углеводороды, парафины, алифатические соединения) — ациклические углеводороды линейного или разветвленного строения, содержащие только простые связи. Алканы являются насыщенными углеводородами и содержат максимально возможное число атомов водорода. Каждый атом углерода в молекулах алканов находится в состоянии sp3-гибридизации — все четыре гибридные орбитали атома С идентичны по форме и энергии, четыре связи направлены в вершины тетраэдра под углами 109∘28. Cвязи C–C представляют собой σ-связи, отличающиеся низкой полярностью и поляризуемостью.  
Если вы дочитали до сюда, то алканы — углеводороды, то есть соединения, состоящие из атомов углерода и водорода, не содержащие связей водород–водород, причём каждый углерод соединен ровно с четырьмя другими атомами, а каждый водород соединен ровно с одним другим атомом. При этом алкан является связным соединением, а также молекула алкана не является цикличной (для каждых двух атомов существует единственный способ добраться из одного в другой по связям между атомами).  
Задание такое же простое как и условие - по данной молекуле определить, является ли она алканом.
### Формат ввода:
В первой строке содержатся два числа N и M (1 ≤ N ≤ 10<sup>5</sup>, 0 ≤ M ≤ 10<sup>5</sup>) --- количество атомов и соединений между атомами соответственно.  
Следующая строка состоит из N символов. Если i-й символ — «C», то i-й атом — атом углерода. Если i-й символ — «H», то i-й атом — атом водорода. Гарантируется, что каждой символ этой строки — либо «C», либо «H».  
В следующих M строках содержатся описания соединений между атомами. В i-й из них содержатся номера двух атомов, связанных i-м соединением. Нумерация с единицы
### Формат вывода:
Выведите «YES», если соединение является алканом, и «NO», если не является.
## [V. Водосток](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/V.cpp)
Карту местности условно разбили на квадраты, и посчитали среднюю высоту над уровнем моря для каждого квадрата.

Когда идет дождь, вода равномерно выпадает на все квадраты. Если один из четырех соседних с данным квадратом квадратов имеет меньшую высоту над уровнем моря, то вода с текущего квадрата стекает туда (и, если есть возможность, то дальше), если же все соседние квадраты имеют большую высоту, то вода скапливается в этом квадрате.

Разрешается в некоторых квадратах построить водостоки. Когда на каком-то квадрате строят водосток, то вся вода, которая раньше скапливалась в этом квадрате, будет утекать в водосток.

Если есть группа квадратов, имеющих одинаковую высоту и образующих связную область, то если хотя бы рядом с одним из этих квадратов есть квадрат, имеющий меньшую высоту, то вся вода утекает туда, если же такого квадрата нет, то вода стоит во всех этих квадратах. При этом достаточно построить водосток в любом из этих квадратов, и вся вода с них будет утекать в этот водосток.

Требуется определить, какое минимальное количество водостоков нужно построить, чтобы после дождя вся вода утекала в водостоки.
### Формат ввода:
Во входном файле записаны сначала числа N и M, задающие размеры карты — натуральные числа, не превышающие 100. Далее идет N строк, по M чисел в каждой, задающих высоту квадратов карты над уровнем моря. Высота задается натуральным числом, не превышающим 10000. Считается, что квадраты, расположенные за пределами карты, имеют высоту 10001 (то есть вода никогда не утекает за пределы карты).
### Формат вывода:
В выходной файл выведите минимальное количество водостоков, которое необходимо построить.
## [W. Восстановление графа](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Second_contest/W.cpp)
В Физтех-школе Прикладной Математики и Информатики студенты изучают теорию графов. К сожалению, студент Демид не очень хорош в ней с математической точки зрения, но знает огромное множество алгоритмов в этой области. Поэтому многие теоремы он доказывает результатами работы некоторого алгоритма и их последующей обработкой. Но однажды ему задали непосильную задачу, помочь решить которую он просит вас. Перейдем к самой задаче.  
Дан неориентированный связный граф без петель и кратных ребер на N вершинах, которые занумеровали от 1 до N. Затем на каждое ребро выписали сумму номеров вершин, которое оно соединяет, а изначальную нумерацию вершин стерли.  
Для удобства работы с графом, вершины уже занумеровали от 1 до N каким-то образом, то есть формально надо найти такую перестановку p[], что если p[i] = k, то i-я вершина во входных данных имела номер k в исходном графе.
### Формат ввода:
На первой строке дано два натуральных числа N, M (1 ≤ N, M ≤ 10<sup>6</sup>) — количество вершин и ребер в графе. Далее на M строках идут описания ребер в виде трех чисел u, v, c (1 ≤ u, v ≤ N, u ≠ v, 3 ≤ c ≤ 2N - 1 ) — ребро между вершинами с номерами u, v с написанным на нем числом c.
### Формат вывода:
Выведите массив из N чисел через пробел — искомая перестановка. Гарантируется, что ответ есть.
# [Cpp Second_contest](https://github.com/PlatonYadrov/Second_semester/tree/main/cpp/Second_contest)
## [J. Stack](https://github.com/PlatonYadrov/Second_semester/blob/main/cpp/Second_contest/Stack.h)
_Контейнерные адаптеры представляют собой обертку над последовательными контейнерами, которые предоставляют ограниченный интерфейс взаимодействия соответствующий определенному абстрактному типу данных._  
#### Задание:
Реализуйте контейнерный адаптер `Stack`, аналог `std::stack`, параметризованный шаблонным типом хранимых элементов `T` и контейнером `Container`, который лежит в его основе (значение по умолчанию - `std::deque<T>`). Реализуйте следующие методы:  
•	Конструктор по умолчанию;  
•	Конструктор от контейнера `Container`;  
•	Конструктор от пары итераторов;  
•	`Top()`;  
•	`Empty()`;  
•	`Size()`;  
•	`Push(value)`;  
•	`Emplace(args...)`;  
•	`Pop()`;  
•	`Swap(Stack&)`.
## [K. Vector](https://github.com/PlatonYadrov/Second_semester/blob/main/cpp/Second_contest/Vector.h)
Пришлите архив с файлом vector.h и, возможно, другими файлами реализации.
### Vector
Ранее в курсе был рассмотрен класс динамической строки `std::string` (см. задание String), которая увеличивает размер массива символов по мере необходимости и самостоятельно управляет выделяемой памятью. В этом задании мы рассмотрим класс `std::vector`, являющийся обобщением динамической строки на произвольный тип, то есть класс динамического массива.
### `std::vector`
Интерфейс и реализация `std::vector<T>` во многом похожи на `std::string`. Ключевым отличием является семантика работы метода reserve (и остальных методов, которые приводят к увеличению `capacity`). При резервировании памяти под большее число объектов, выделяется "сырая" (неинициализированная) память достаточная для хранения нужного числа дополнительных объектов. Пустые ячейки заполняются лениво по мере необходимости. То есть, если `size < capacity`, то это значит, что первые `size * sizeof(T)` байт реально заняты объектами, а последние `(capacity - size) * sizeof(T)` байт пусты - объектов там не создано (как такого добиться - см. задание Optional). Это нужно, например, для того, чтобы можно было создавать вектор из объектов, у которых нет конструктора по умолчанию (а как бы тогда нужно было инициализировать неиспользуемые ячейки?):
```
struct A {
  int x;

  A() = delete;
  explicit A(int x_param) : x(x_param) {
  }
};

std::vector<A> v;
v.reserve(1000);  // объекты A не создаются! Выделяется "сырая" память размера 1000 * sizeof(A)
for (int i = 0; i < 1000; ++i) {
  v.push_back(A(i));
  // а лучше v.emplace_back(i);
}
```
Подробности на лекциях, семинарах, в чатах, на заборе, а также [в справочнике](https://en.cppreference.com/w/cpp/container/vector).
### Детали реализации
От вас требуется реализовать шаблонный класс `Vector` с единственным шаблонным параметром - типом хранящихся элементов. При реализации можно (и даже нужно) пользоваться обобщенными алгоритмами из STL (`std::copy`, `std::fill` и т.п.), но нельзя использовать стандартные контейнеры. Будет проверяться корректность мультипликативной схемы расширения массива с коэффициентом 2. В базовой версии ручное управление временем жизни объектов не требуется (см. доп. задание). Класс должен поддерживать следующий функционал:  
•	Конструктор по умолчанию - создает пустой массив;  
•	Явный конструктор от числа - создает массив заданного размера заполненный объектами, сконструированными по умолчанию;  
•	Конструктор, принимающий `size` и `value` (именно в этом порядке) - создает массив длины `size`, заполненный элементами со значением `value`;  
•	Шаблонный конструктор, принимающий пару итераторов - создает копию переданного диапазона;  
__Важно:__ объявление этого конструктора должно иметь вид
```
template <class Iterator, class =
std::enable_if_t<std::is_base_of_v<std::forward_iterator_tag, typename
std::iterator_traits<Iterator>::iterator_category>>>
Vector(Iterator first, Iterator last)
```
Это делает конструктор доступным только в случае, когда на вход приходят два Forward итератора.
*	Конструктор от `std::initializer_list`;
*	Правило "пяти";
*	Методы `Size`, `Capacity`, `Empty`;
*	Константный и неконстантный оператор доступа по индексу `[]`. Неконстантный должен позволять изменять полученный элемент;
*	Константный и неконстантный метод доступа по индексу `At`. При выходе за границы массива должен бросать исключение `std::out_of_range`;
*	Методы `Front()` и `Back()`
    * доступ к первому и последнему элементам (тоже по две версии).
*	Метод `Data()`
    * возвращает указатель на начало массива.
*	Метод `Swap(other)`
    * обменивает содержимое с другим массивом `other`;
*	Метод `Resize(new_size)`
   * изменяет размер на `new_size`. Если вместимость не позволяет хранить столько элементов, то выделяется новый буфер с вместимостью `new_size`. Недостающие элементы конструируются по умолчанию.
*	Метод `Resize(new_size, value)`
   * то же, что и `Resize(new_size)`, но в случае `new_size > size` заполняет недостающие элементы значением `value`.
*	Метод `Reserve(new_cap)`
   * изменяет вместимость на `max(new_cap, текущая вместимость)`. Размер при этом не изменяется.
*	Метод `ShrinkToFit()`
   * уменьшает `capacity` до `size`.
*	Метод `Clear()`
   * устанавливает размер в 0, очищения выделенной памяти при этом НЕ происходит.
*	Методы `PushBack(const T&)` и `PushBack(T&&)`
   * добавляет новый элемент в конец массива.
*	Метод `PopBack()`
   * удаляет последний элемент.
*	Операции сравнения `(<, >, <=, >=, ==, !=)`, задающие лексикографический порядок.

Также реализуйте поддержку итераторов и методы для работы с ними: `begin(), end(), cbegin(), cend(), rbegin(), rend(), crbegin(), crend(). begin()-end(), rbegin()-rend()` должны иметь две версии, возвращающие константные и неконстантные итераторы.  
Внутри класса `Vector` определите типы-члены `ValueType, Pointer, ConstPointer, Reference, ConstReference, SizeType, Iterator, ConstIterator`.

### Гарантии безопасности
Спроектируйте класс так, чтобы при возникновении исключений (нехватка памяти, ошибка при копировании объектов и т.п.) методы удовлетворяли строгой гарантии безопасности. То есть все методы должны работать атомарно: либо работать без сбоев, либо не изменять исходного состояния вектора. Исключение: копирующее присваивание может давать лишь базовую гарантию безопасности.

__При решении можно предполагать, что конструкторы перемещения, перемещающие присваивания и деструкторы объектов никогда не бросают исключений!__
## [L. Optional](https://github.com/PlatonYadrov/Second_semester/blob/main/cpp/Second_contest/Optional.h)
Пришлите архив с файлом optional.h и, возможно, другими файлами реализации.
### Optional
_Это задание познакомит вас с основами ручного управления временем жизни объектов на примере класса `Optional`._

При создании объектов на стеке компилятор самостоятельно выделяет память достаточную для хранения объекта и инициализирует объект, вызывая соответствующий конструктор, а при выходе из блока самостоятельно очищает память и завершает время жизни объекта посредством вызова деструктора.

Если речь идет про динамическую область памяти, то этот процесс частично контролируется пользователем - операция new заставляет выделить память под объект в куче и создать его там же, операция `delete` инициирует вызов деструктора и освобождает выделенную память.

А что, если хочется самостоятельно определять в какой момент объект должен быть создан и уничтожен, то есть не привязывать время жизни объекта к памяти, которая его содержит? Это может быть полезно, например, для эффективной работы `std::vector<T>` - если объекты типа `T` требуют много ресурсов на создание, то может быть накладно иметь `capacity` объектов, когда реально используется только `size` из них. Для решения этой проблемы `std::vector` хранит лишь "сырую" память достаточную для хранения `capacity` объектов, а сами объекты создаются и удаляются вручную по мере необходимости.
### Placement new и явный вызов деструктора
Для ручного создания объекта по конкретному месту в памяти (заранее выделенного на стеке или в куче) можно воспользоваться специальной формой оператора new - [placement new](https://ru.wikipedia.org/wiki/New_(C%2B%2B)#Placement_new).

Пусть `ptr` - указатель на область памяти достаточного размера для хранения объекта типа `T`. Чтобы создать объект в данном месте можно воспользоваться следующим синтаксисом: `c++ new(ptr) T(args...)`; `// args...` - аргументы конструктора

Заметьте, что отличие состоит в явном указании адреса в скобках и _отсутствии выделения дополнительной памяти_.
Приведем пример __неправильного использования__ _placement new_:
`A a`;                 // создаем объект типа A
`new(&a) A("param")`;  // пересоздаем объект, деструктор старого объекта при этом не вызывается!
Для корректной работы предыдущего примера необходимо удалить старый объект перед созданием нового: `c++ A a`; // создаем объект типа `A a.~A()`; // явно вызываем деструктор старого объекта `new(&a) A("param")`; // создаем новый объект

Код вида `a = A("param")`; логически эквивалентен приведенному выше, но отличается с точки зрения времени жизни объектов. Кроме того, код выше работает и в случае, когда для класса A не определен оператор присваивания.

Важно отметить, что после последнего создания явно вызвать деструктор не нужно, так как компилятор вызывает его самостоятельно при выходе из блока: `c++ A a`; // создаем объект типа `A a.~A()`; // явно вызываем деструктор старого объекта `new(&a) A("param")`; // создаем новый объект `a.~A()`; // UB: деструктор вновь вызовется при выходе из блока

Для создания объекта "с нуля" в сырой памяти нужно сначала предоставить эту память, а затем приступить к созданию:

`char memory[sizeof(A)]`;  // создаем сырую память размера `sizeof(A)` байт  
`A* obj = new(memory) A("param")`;  // создаем объект `A`, возвращается тот же указатель, но типа `A*`  
`// ... use of A`  
`obj->~A()`;  // важно самостоятельно вызвать деструктор! `memory` будет освобожден как массив char, а не как объект `A`  
Аналогичный пример в динамической памяти: `c++ char* memory = new char[sizeof(A)]`; // или `operator new(sizeof(A)); A* obj = new(memory) A("param")`; `// ... use of A obj->~A(); delete[] memory`; // так как выделяли массив `char`, то и удалять нужно массив `char` // или `operator delete(memory)`;  

Вместо массива `char` в качестве сырой памяти под объекты можно использовать стандартный тип [std::aligned_storage_t](https://en.cppreference.com/w/cpp/types/aligned_storage).
### `std::optional (C++17)`
Шаблон `std::optional` предоставляет безопасный интерфейс для управления временем жизни объектов. Он принимает ровно 1 шаблонный параметр (тип хранимого объекта) и может находиться в одном из двух состояний - объект жив или объект мертв.

В любой момент времени можно узнать состояние объекта (`has_value`), или изменить его (`emplace, reset`). При этом класс самостоятельно принимает решение о том в какой момент вызывать деструктор/конструктор объекта, освобождая пользователя от этих забот.

#### Пример:
```
std::optional<std::vector<int>> opt;  // opt не содержит внутри себя вектора (даже пустого)
opt.has_value();  // false
opt = std::vector<int>(3);  // теперь содержит вектор из 3 чисел
opt.has_value();  // true
(*opt)[2];  // для обращения к объекту нужно "разыменовать" opt или вызвать метод value()
opt.reset();  // вектор уничтожен, opt теперь ничего не хранит
Этот класс может быть полезен, например, для реализации функций, которые не всегда должны что-то возвращать:

std::optional<double> Divide(double x, double y) {
    if (y == 0.0) {
        return {};  // или std::nullopt
    }
    return x / y;
}

auto res = Divide(1.0, 0.0);
if (res) {  // умеет неявно преобразовываться в bool
    std::cout << *res;
}
```
#### Детали реализации
Реализуйте шаблон `Optional<T>`, упрощенный аналог `std::optional<T>`. В полях шаблона сохраните память (массив `char` или `std::aligned_storage_t`) достаточного размера (память должна располагаться на стеке!), а также булевское поле, в котором будет храниться информация о том жив ли объект. Шаблонный класс должен поддерживать следующие методы:  
•	Конструктор по умолчанию. Создает `Optional` с "мертвым" объектом.  
•	Конструктор копирования. Создает копию, если копируемый объект жив, и пустой `Optional` иначе.  
•	Конструктор перемещения. Если перемещаемый `Optional` пуст, то создается пустой объект. Иначе перемещаем объект из другого `Optional`. При этом старый `Optional` по прежнему остается живым!  
•	Неявный конструктор от `const T&` и `T&&`. Создает `Optional` созданный с помощью переданного объекта (копированием или перемещением)  
•	Деструктор. Вызывает деструктор объекта, если тот жив, и ничего не делает, если мертв.  
•	Копирующее и перемещающее присваивание. Если копируемый(перемещаемый) объект мертв, то и свой объект становится мертвым. Иначе своему объекту нужно соответствующим образом присвоить другой (и если был мертв, то оживить).  
•	Присваивание от `const T&` и `T&&`. Аналогично предыдущему (только копируемый объект априори жив).  
•	`bool HasValue()`. Возвращает жив объект, либо нет.  
•	Явное приведение к `bool`. Аналогично предыдущему.  
•	`Value()`. Возвращает ссылку на объект. Если объект мертв, то бросается исключение `BadOptionalAccess` (которое тоже надо реализовать). Поддержать константную и неконстантную версии.  
•	Константный и неконстантный `operator*. Аналогичен Value`, но не осуществляет проверок.
•	T& Emplace(args...). Принимает аргументы конструктора, с которыми нужно пересоздать объект (если он был жив, то вызвать деструктор и создать заново).
•	void Reset(). Уничтожить объект, если тот был жив.
#### Замечания.
1.	https://en.cppreference.com/w/cpp/utility/optional  
2.	Существует неприятная проблема связанная с использованием указателя на "сырую" память, которая была ранее занята другим объектом (https://en.cppreference.com/w/cpp/utility/launder). Для упрощения реализации мы игнорируем эту проблему (она проявляется только при работе с объектами с константными или ссылочными полями, в тестах таких случаев нет).
## [N. Itertools.Range](https://github.com/PlatonYadrov/Second_semester/blob/main/cpp/Second_contest/Itertools_Range.h)
### Itertools
_Одним из минусов языка `C++` является отсутствие удобного интерфейса работы с последовательностями и промежутками значений, который, по большому счету сводится к ручному написанию циклов и работе со встроенными итераторами. С введением библиотеки [<ranges>](https://en.cppreference.com/w/cpp/ranges) в `C++20` ситуация заметно улучшилась. В этом цикле задач мы попытаемся решить заявленную проблему средствами `C++17`._
#### Range
Для написания цикла по целым значениям в C++ необходимо написать следующий код:
```
for (int i = 0; i < end; ++i) {
    // ...
}

for (int i = begin; i < end; ++i) {
    // ...
}

for (int i = begin; i < end; i += step) {
    // ...
}
```
Сравните, например, с языком Python:
```
for i in range(end):
    # ...

for i in range(begin, end):
    # ...

for i in range(begin, end, step):
    # ...
Хотелось бы иметь подобный лаконичный код и в C++ (благо range-based for завезли в C++11):


for (int i : range(end)) {
    // ...
}

for (int i : range(begin, end)) {
    // ...
}

for (int i : range(begin, end, step)) {
    // ...
}
```
Проблема в том, что в стандартной библиотеке (до `C++20`) нет сущности range, которую можно было использовать в подобном контексте. Ну а раз так - надо ее реализовать самостоятельно!

### Детали реализации
Необходимо реализовать` Range` (класс или функцию), который возвращает объект некоторого класса (вам нужно его реализовать) с определенными методами `begin` и `end`. Эти методы должны возвращать итератор (его тоже нужно реализовать), который при разыменовывании возвращает соответствующее целое значение, а при инкрементировании увеличивает свое состояние на `step` (по умолчанию `step == 1`).

__Примеры:__ (больше примеров см. в тестах)

```
for (int i : Range(3)) { ... }  // i in [0, 1, 2]

for (int i : Range(3, 6)) { ... }  // i in [3, 4, 5]

for (int i : Range(3, 6, 2)) { ... }  // i in [3, 5]

for (int i : Range(6, 1, -2)) { ... }  // i in [6, 4, 2]
```
_Указание: вспомните как работает range-based for в C++._
### Дополнительное задание
Поддержать обратные итераторы (см. примеры в тестах). Добавьте директиву `#define REVERSE_RANGE_IMPLEMENTED` в файл с решением для проверки дополнительного задания.
## [P. Itertools.Reversed](https://github.com/PlatonYadrov/Second_semester/blob/main/cpp/Second_contest/Itertools_Reversed.h)
### Itertools
_Одним из минусов языка C++ является отсутствие удобного интерфейса работы с последовательностями и промежутками значений, который, по большому счету сводится к ручному написанию циклов и работе со встроенными итераторами. С введением библиотеки [<ranges>](https://en.cppreference.com/w/cpp/ranges) в C++20 ситуация заметно улучшилась. В этом цикле задач мы попытаемся решить заявленную проблему средствами C++17._
### Reversed
Для прохода по контейнеру в обратном порядке в C++ необходимо написать подобный код:
```
for (auto it = container.rbegin(); it != container.rend(); ++it) {
    // ...
}
Сравните, например, с языком Python:


for x in reversed(container):
    # ...
Хотелось бы иметь подобный лаконичный код и в C++ (благо range-based for завезли в C++11):


for (auto&& x : reversed(container)) {
    // ...
}
```
Проблема в том, что в стандартной библиотеке (до C++20) нет сущности reversed, которую можно было использовать в подобном контексте. Ну а раз так - надо ее реализовать самостоятельно!

### Детали реализации
Необходимо реализовать Reversed (класс или функцию), который возвращает объект некоторого класса (вам нужно его реализовать) с определенными методами begin и end. Эти методы должны возвращать соответствующие обратные итераторы переданного контейнера.

__Примеры:__ (больше примеров см. в тестах)
```
std::vector<int> v{1, 2, 3, 4, 5};

for (int x : Reversed(v)) { ... }  // x in [5, 4, 3, 2, 1]

for (int& x : Reversed(v)) {
    x = 0;
}
// v == {0, 0, 0, 0, 0}
```
_Указание: вспомните как работает range-based for в C++._
### Дополнительное задание 1
Поддержать обратные итераторы (см. примеры в тестах). Добавьте директиву `#define REVERSE_REVERSED_IMPLEMENTED` в файл с решением для проверки дополнительного задания.

### Дополнительное задание 2
При наивной реализации (описанной в задании) Reversed не сможет работать со временными контейнерами:

`for (auto x : Reversed(std::vector<int>{1, 2, 3, 4, 5})) { ... }  // Undefined behaviour!`
Это связано с тем, что цикл будет работать с "висячими" (невалидными) итераторами, так как контейнер, на который они ссылаются, будет уничтожен.

Решить эту проблему можно с помощью специализации `Reversed` на случай `rvalue` объектов. В этом случае в полях класса необходимо сохранять не итераторы `rbegin` и `rend`, а контейнер целиком. Так мы гарантируем, что сохраненный контейнер не будет уничтожен до выхода из цикла, и итераторы всегда будут ссылаться на живой объект.

Добавьте директиву `#define TEMPORARY_REVERSED_IMPLEMENTED` в файл с решением для проверки дополнительного задания.
# [Algorithms Third_contest](https://github.com/PlatonYadrov/Second_semester/tree/main/Algorithms/Third_contest)
## [A. Острова](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/A.cpp)
Одно разбросанное на островах Океании государство решило создать сеть автомобильных дорог (вернее, мостов). По каждому мосту можно перемещаться в обе стороны. Был разработан план очередности строительства мостов и известно, что после постройки всех мостов можно будет проехать по ним с каждого острова на каждый (возможно, через некоторые промежуточные острова).  
Однако, этот момент может наступить до того, как будут построены все мосты. Ваша задача состоит в определении такого минимального количества мостов, после постройки которого (в порядке строительства по плану) можно будет попасть с любого острова на любой другой.
### Формат ввода:
Первая строка содержит два числа: N — число островов (1 ≤ N ≤ 100000) и M — количество мостов в плане (1 ≤ M ≤ 200000). В каждой следующей строке содержится описание моста — два числа x и y (0 ≤ x, y < N) — номера соединяемых островов.
### Формат вывода:
Выведите в выходной файл одно число — минимальное количество построенных мостов, по которым можно попасть с любого острова на любой.
## [B. Вес компоненты](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/B.cpp)
В неориентированный взвешенный граф добавляют ребра. Напишите программу, которая в некоторые моменты находит сумму весов ребер в компоненте связности.
### Формат ввода:
В первой строке записано два числа n и m (1 ≤ n, m ≤ 10<sup>6</sup>) — количество вершин в графе и количество производимых добавлений и запросов. Далее следует m строк с описанием добавления или запроса. Каждая строка состоит из двух или четырех чисел.  
Первое из чисел обозначает код операции. Если первое число 1, то за ним следует еще три числа x, y, w. Это означает, что в граф добавляется ребро xy веса w (1 ≤ x < y ≤ n, 1 ≤ w ≤ 1000). Кратные ребра допустимы.  
Если первое число 2, то за ним следует ровно одно число x. Это означает, что необходимо ответить на вопрос, какова сумма весов ребер в компоненте связности, которой принадлежит вершина x (1 ≤ x ≤ n).
### Формат вывода:
Для каждой операции с кодом 2 выведите ответ на поставленную задачу. Ответ на каждый запрос выводите на отдельной строке.
## [C. Прим](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/C.cpp)
Требуется найти в связном графе остовное дерево минимального веса. Задачу решайте с помощью алгоритма Прима
### Формат ввода:
Первая строка входного файла содержит два натуральных числа n и m — количество вершин и ребер графа соответственно (1 ≤ n ≤ 20000, 0 ≤ m ≤ 100000). Следующие m строк содержат описание ребер по одному на строке. Ребро номер i описывается тремя натуральными числами b<sub>i</sub>, e<sub>i</sub> и w<sub>i</sub> — номера концов ребра и его вес соответственно (1 ≤ b<sub>i</sub>, e<sub>i</sub> ≤ n, 0 ≤ w<sub>i</sub> ≤ 100000).
### Формат вывода:
Выведите единственное целое число — вес минимального остовного дерева.
## [D. Краскал](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/D.cpp)
Дан связный неориентированный граф, в котором надо найти остовное дерево минимального веса с помощью алгоритма Краскала. Гарантируется, что ребра будут отсортированы по весу по неубыванию.
### Формат ввода:
В первой строке идут два натуральных числа N и M (2 ≤ N ≤ 5 ⋅ 10<sup>4</sup>, 1 ≤ M ≤ 2 ⋅ 10<sup>6</sup>). Далее идет M строк — описания ребер в формате u, v, w (1 ≤ u < v ≤ N, 1 ≤ w ≤ 10<sup>4</sup>) — ребро между вершинами u и v веса w.
### Формат вывода:
Вывести вес минимального остового дерева.
## [E. Борувка](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/E.cpp)
Дан связный неориентированный граф, в котором надо найти остовное дерево минимального веса с помощью алгоритма Борувки.
### Формат ввода:
В первой строке идут два натуральных числа N и M (2 ≤ N ≤ 5 ⋅ 10<sup>4</sup>, 1 ≤ M ≤ 2 ⋅ 10<sup>6</sup>). Далее идет M строк — описания ребер в формате u, v, w (1 ≤ u < v ≤ N, 1 ≤ w ≤ 10<sup>4</sup>) — ребро между вершинами u и v веса w.
### Формат вывода:
Вывести вес минимального остового дерева.
## [F. Шпионы](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/F.cpp)
Вы — глава агенства, в котором работает N сотрудников — шпионы с кодовыми номерами от 1 до N. Шпионы были посланы в различные страны и получили кусочки важной информации. Ваша задача состоит в следующем:  
1.	Организовать встречи между некоторыми шпионами. На каждой такой встрече ровно два шпиона оказываются в одном месте и обмениваются всей информацией, которую получили сами или узнали от других шпионов на предыдущих встречах. Каждую из возможных встреч сложно и затратно организовать, поэтому вам известны все стоимости.  
2.	После того, как все встречи состоялись, выбирается группа шпионов, и они посылаются на задание по спасению мира. Для каждого шпиона известно, сколько денег он изведет, если его включить в эту группу. Задание должно быть выполнено, поэтому очень важно, чтобы выбранные шпионы все вместе обладали всей информацией, полученной агенством.  
Найдите минимальную цену, за которую можно спасти мир.
### Формат ввода:
Первая строка содержит натуральное число N — количество шпионов (2 ≤ N ≤ 1000). Каждая из следующих строк содержит N натуральных чисел, не превосходящих 10<sup>6</sup>. Число в k-й строке и m-м столбце обозначает стоимость встречи между шпионами k и m и совпадает с числом в m-й строке и k-м столбце (если k = m, то соответствующее число будет равно 0). Следующая строка содержит n чисел, i-е из них равно стоимости послать i-го шпиона на задание. Все стоимости являются положительными целыми числами.
### Формат вывода:
Выведите одно число — минимальную стоимость спасения мира.
## [G. Предатель отрицательного веса](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/G.cpp)
Вы член команды на космическом корабле в игре Among Us. Однако, один из ваших товарищей — скрытый враг, который пытается помешать вам выполнить миссию. Ваша задача — найти кратчайшие пути от вашей текущей позиции на вершине 1 до каждой другой вершины в графе.  
Граф содержит отрицательно взвешенные ребра, но при этом не имеет отрицательных циклов. Это означает, что вам не нужно беспокоиться о бесконечном цикле отрицательного веса, который мог бы затянуть вашу команду в бесконечный круг. Однако, вы все еще должны быть осторожны и находиться начеку, чтобы избежать других ловушек, которые может подготовить скрытый враг, чтобы остановить вас.  
Сможете ли вы обнаружить скрытого врага и найти кратчайший путь к каждой вершине, чтобы выполнить миссию команды и спасти корабль?
### Формат ввода:
Число вершин равно N (1 ≤ N ≤ 100), а число ребер равно M (0 ≤ M ≤ 10000). В следующих строках идет M троек чисел, описывающих ребра: начало, конец и вес (целое число от -100 до 100).
### Формат вывода:
Программа должна вывести N чисел — веса кратчайших путей от вершины 1 до всех остальных. Если нельзя прийти от первой вершины до некоторой, то вместо усилия выведите число 30000.
## [H. Авиаперелеты](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/H.cpp)
Профессору Форду необходимо попасть на международную конференцию. Он хочет потратить на дорогу наименьшее количество денег, поэтому решил, что будет путешествовать исключительно ночными авиарейсами (чтобы не тратиться на ночевку в отелях), а днем будет осматривать достопримечательности тех городов, через которые он будет проезжать транзитом. Он внимательно изучил расписание авиаперелетов и составил набор подходящих авиарейсов, выяснив, что перелеты на выбранных направлениях совершаются каждую ночь и за одну ночь он не сможет совершить два перелета.  
Теперь профессор хочет найти путь наименьшей стоимости, учитывая что до конференции осталось K ночей (то есть профессор может совершить не более K перелетов).
### Формат ввода:
В первой строке находятся числа N (2 ≤ N ≤ 100) (количество городов), M (1 ≤ M ≤ 10<sup>5</sup>) (количество авиарейсов), K (1 ≤ K ≤ 100) (количество оставшихся ночей), S (1 ≤ S ≤ N) (номер города, в котором живет профессор), F (1 ≤ F ≤ N) (номер города, в котором проводится конференция).  
Далее идет M строк, задающих расписание авиарейсов. i-я строка содержит три натуральных числа: S<sub>i</sub>, F<sub>i</sub> и P<sub>i</sub>, где S<sub>i</sub> — номер города, из которого вылетает i-й рейс, F<sub>i</sub> — номер города, в который прилетает i-й рейс, P<sub>i</sub> — стоимость перелета i-м рейсом. Гарантируется, что 1 ≤ S<sub>i</sub> ≤ N, 1 ≤ F<sub>i</sub> ≤ N, 1 ≤ P<sub>i</sub> ≤ 10<sup>6</sup>.
### Формат вывода:
Выведите одно число — минимальную стоимость пути, подходящего для профессора. Если профессор не сможет за K ночей добраться до конференции, выведите число -1.
## [I. Дейкстра](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/I.cpp)
В этой задаче вы являетесь членом команды на космическом корабле в игре "Among Us". На корабле имеется N комнат, каждая из которых представлена вершиной в графе. Вы и ваши командные товарищи пытаетесь выполнять задания и поддерживать работоспособность корабля, но среди вас есть подлец, который пытается помешать вам.  
Подлец взломал навигационную систему корабля и создал K графов, представляющих различные карты расположения комнат на корабле. Ваша задача состоит в том, чтобы найти кратчайший путь от вашего текущего местоположения до каждой из других комнат.  
Каждая вершина представляет комнату на корабле, а каждое ребро представляет коридор, соединяющий две соседние комнаты. Вес каждого ребра представляет время, необходимое для перемещения между комнатами.  
Сможете ли вы и ваши товарищи по команде пройти по кораблю и выполнить свои задания?
### Формат ввода:
В первой строке входных данных задано число K — количество различных карт комнат на корабле, где герои могут находиться. Далее следуют K блоков, каждый из которых имеет следующую структуру.  
Первая строка блока содержит два числа N и M, разделенные пробелом — количество комнат и переходов. Далее следуют M строк, каждая из которых содержит по три целых числа, разделенные пробелами. Первые два из них в пределах от 0 до N - 1 каждое и обозначают комнаты на концах соответствующего перехода, третье — в пределах от 0 до 20000 и обозначает длину этого коридора. Далее, в последней строке блока, записанное единственное число от 0 до N - 1 — вершина, где вы расположены.  
Количество различных карт в одном тесте K не превышает 5. Количество вершин не превышает 60000, рёбер — 200000.
### Формат вывода:
Выведите в стандартный вывод K строк, в каждой из которых по N<sub>i</sub> чисел, разделенных пробелами — расстояния от указанной начальной комнаты до его 0-й, 1-й, 2-й и т. д. комнат (допускается лишний пробел после последнего числа). Если некоторая комната недостижима от указанной начальной, вместо расстояния выводите число 2009000999 (гарантировано, что все реальные расстояния меньше).
## [J. Еще раз Дейкстра](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/J.cpp)
Дан ориентированный граф, рёбрам которого приписаны некоторые неотрицательные веса (длины). Найти длину кратчайшего пути из вершины s в вершину t.
### Формат ввода:
В первой строке заданы три числа: число вершин в графе N (N ≤ 2 ⋅ 10<sup>3</sup>), номера вершин s и t. Далее идёт матрица смежности графа, то есть N строк, в каждой из которых записано N чисел. j-е число в i-й строке матрицы смежности задает длину ребра, ведущего из i-й вершину в j-ю. Длины могут принимать любые значения от 0 до 10<sup>6</sup>, число -1 означает отсутствие соответствующего ребра. Гарантируется, что на главной диагонали матрицы стоят нули.
### Формат вывода:
Выведите одно число — минимальную длину пути. Если пути не существует, выведите -1.
## [K. Циклический саботаж](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/K.cpp)
Вы являетесь членом команды на космическом корабле. Ваша задача — убедиться, что все системы функционируют должным образом и корабль может выполнить свою миссию. Однако вы получили сообщение от подозрительного члена экипажа, что в одной из систем есть саботаж.  
Как член команды, вы знаете, что саботаж может негативно сказаться на миссии корабля. В командном центре корабля есть компьютер, который показывает общую производительность корабля.  
Вам нужно написать программу, которая проверяет, есть ли саботаж в какой-либо из систем корабля, который может повлиять на миссию корабля. Вы можете представить системы корабля в виде ориентированного графа, где каждое ребро имеет вес. Отрицательный вес означает наличие (и степень) саботажа в этой системе, а положительный вес означает работоспособность (и надежность) системы.  
Если в системе корабля найдется цикл отрицательного веса, то саботаж успешен.
### Формат ввода:
В первой строке содержится число N (1 ≤ N ≤ 100) — количество вершин графа системы. В следующих N строках находится по N чисел — матрица смежности графа. Веса ребер по модулю меньше 100000. Если ребра нет, соответствующее значение равно 100000.
### Формат вывода:
В первой строке выведите YES, если цикл существует, или NO, в противном случае.  
При наличии цикла выведите во второй строке количество вершин в нем (считая одинаковые — первую и последнюю), а в третьей строке — вершины, входящие в этот цикл, в порядке обхода. Если циклов несколько, то выведите любой из них.
## [L. Джонсон](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/L.cpp)
Урбанист Варлам Ильинов каждый день катается на своем велосипеде по городу, оценивая качество велосипедных дорог, а также доступность его любимых кофеен. За годы своих трудов он смог составить подробную карту каждого района и выяснить за какое время он сможет добраться от одной кофейни до другой. Кроме того, если от одной кофейни до другой есть трамвайная линия, то он впадает в неистовый восторг и считает, что время на этом пути не тратится, а наоборот приобретается.  
Теперь он хочет измерить удобность транспортной инфраструктуры. Чем меньше максимальное расстояние между кофейнями, тем более удобным считается город. При этом, если от одной кофейни нельзя добраться до другой ни по велосипедным дорожкам, ни с помощью трамвая, то такая (упорядоченная) пара игнорируется при подсчете удобности.  
Необходимо найти пару кофеен, кратчайшее расстояние от одной из которых до другой максимально среди всех пар, между которыми есть какой-либо путь.
### Формат ввода:
В первой строке вводятся числа N и M (1 ≤ N ≤ 10<sup>3</sup>, 1 ≤ M ≤ 5 ⋅ N) — количество кофеен и общее количество велосипедных дорожек и трамвайных путей. В следующих M строках задаются числа a, b, w, что означает наличие пути от кофейни a до кофейни b длины w ∈ [-100, 100] (но не наоборот!). Кофейни нумеруются с 0. Кольцевых трамвайных линий в городе не предусмотрено.
### Формат вывода:
Выведите искомое максимальное конечное кратчайшее расстояние между кофейнями.
## [M. Флойд-Уоршелл](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/M.cpp)
Полный ориентированный взвешенный граф задан матрицей смежности. Постройте матрицу кратчайших путей между его вершинами. Гарантируется, что в графе нет циклов отрицательного веса.
### Формат ввода:
В первой строке вводится единственное число N (1 ≤ N ≤ 100) — количество вершин графа. В следующих N строках по N чисел задается матрица смежности графа (j-е число в i-й строке соответствует весу ребра из вершины i в вершину j). Все числа по модулю не превышают 100. На главной диагонали матрицы всегда нули.
### Формат вывода:
Выведите N строк по N чисел — матрицу кратчайших расстояний между парами вершин. j-е число в i-й строке должно быть равно весу кратчайшего пути из вершины i в вершину j.
## [N. Форд-Фалкерсон](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/N.cpp)
Задан ориентированный граф, каждое ребро которого обладает целочисленной пропускной способностью. Найдите максимальный поток из вершины с номером 1 в вершину с номером n.  
В этой задаче необходимо реализовать алгоритм Форда-Фалкерсона.
### Формат ввода:
Первая строка входного файла содержит n и m — количество вершин и количество ребер графа (2 ≤ n ≤ 100, 1 ≤ m ≤ 1000). Следующие m строк содержат по три числа: номера вершин, которые соединяет соответствующее ребро графа и его пропускную способность. Пропускные способности не превосходят 10<sup>5</sup>.
### Формат вывода:
В выходной файл выведите одно число — величину максимального потока из вершины с номером 1 в вершину с номером n.
## [O. Эдмондс-Карп](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/O.cpp)
Задан ориентированный граф, каждое ребро которого обладает целочисленной пропускной способностью. Найдите максимальный поток из вершины с номером 1 в вершину с номером n.  
В этой задаче необходимо реализовать алгоритм Эдмондса-Карпа.
### Формат ввода:
Первая строка входного файла содержит n и m — количество вершин и количество ребер графа (2 ≤ n ≤ 500, 1 ≤ m ≤ 10000). Следующие m строк содержат по три числа: номера вершин, которые соединяет соответствующее ребро графа и его пропускную способность. Пропускные способности не превосходят 10<sup>9</sup>.
### Формат вывода:
В выходной файл выведите одно число - величину максимального потока из вершины с номером 1 в вершину с номером n.
## [P. Химия](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/P.cpp)
Вася и Сережа играют в следующую игру. В некоторых клетках клетчатого листка Сережа рисует один из символов H, O, N или C, после чего Вася должен провести между некоторыми находящимися в соседних клетках символами линии так, чтобы получилось корректное изображение химической молекулы. К сожалению, Сережа любит рисовать много символов, и Вася не может сразу определить, возможно ли вообще нарисовать линии нужным способом. Помогите ему написать программу, которая даст ответ на этот вопрос.  
В этой задаче проведенные между символами химических элементов линии будем считать корректным изображением молекулы, если они удовлетворяют следующим условиям:  
•	каждая линия соединяет символы, нарисованные в соседних (по стороне) клетках;  
•	между каждой парой символов проведено не более одной линии;  
•	от каждого элемента отходит ровно столько линий, какова валентность этого элемента (1 для H, 2 для O, 3 для N, 4 для C);  
•	пустые клетки ни с чем не соединены;  
•	хотя бы в одной клетке нарисован какой-то символ.  
### Формат ввода:
Первая строка входного файла содержит два натуральных числа n и m (1 ≤ n, m ≤ 50) — размеры листочка, на котором рисует Сережа.  
Далее следуют n строк по m символов в каждой, задающих конфигурацию химических элементов, которую нарисовал Сережа; пустые клетки задаются символом «.».
### Формат вывода:
В выходной файл выведите одно слово Valid, если линии провести требуемым образом можно, и Invalid, если нельзя.
## [R. Маховик сюжета](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/R.cpp)
Поможем Джоан Роулинг развить сюжетную дыру, связанную с маховиками времени. После битвы с тем-кого-нельзя-называть магия вышла на качественно новый уровень. Теперь маховики времени способны не только переносить назад во времени, но и в принципе перемещаться в любую заданную точку мира в любой заданный момент времени. В связи с тем, что это могло бы вызвать хаос, Министерство Магии решило наложить некоторые ограничения на них.  
А именно, есть N магических станций, в которых возможно использование маховиков, при этом любая телепортация может совершаться только в один из этих пунктов. При этом для телепортаций есть определенное расписание. Можно сравнить это с магловскими авиаперелетами, только время работает на руку волшебникам.  
Легенда закончена, теперь сама задача. В момент времени 0 вы находитесь в магической станции A. Вам дано расписание рейсов. Требуется оказаться в магической станции B как можно раньше (то есть в наименьший возможный момент времени).  
При этом разрешается делать сложные маршруты, использующие несколько магических станций. Если вы прибываете на некоторую станцию в момент времени T, то вы можете телепортироваться из него любым рейсом, который отправляется из этой станции в момент времени T или позднее (но не раньше).
### Формат ввода:
В первой строке вводится число N — количество магических станций (1 ≤ N ≤ 1000). Вторая строка содержит два числа A и B — номера начальной и конечной станций. В третьей строке задается K — количество всевозможных телепортаций (0 ≤ K ≤ 1000).  
Следующие K строк содержат описания телепортаций, по одной на строке. Каждое описание представляет собой четверку целых чисел. Первое число каждой четверки задает номер станции отправления, второе — время отправления, третье — станция назначения, четвертое — время прибытия. Номера станций — натуральные числа из диапазона от 1 до N.  
Станции назначения и отправления могут совпадать (да-да, петли в пространстве и времени). Время измеряется в некоторых магических единицах и задается целым числом, по модулю не превышающим 10<sup>9</sup>. Поскольку телепортации совершаются с использованием маховиков времени, то время прибытия может быть как больше времени отправления, так и меньше, или равным ему.  
Гарантируется, что входные данные таковы, что добраться из станции A до станции B всегда можно.
### Формат вывода:
Выведите минимальное время, когда вы сможете оказаться в пункте B.
## [S. Дешифровка по палубам](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/S.cpp)
На космической станции возникла проблема — секретный диск, который хранится в хранилище на палубе 1, был зашифрован. Для его расшифровки требуется доставить его в офис на палубе N. Однако система безопасности изменила условия перемещения на корабле. Теперь за проход по лестнице на один этаж вверх требуется заплатить U единиц, за спуск на один этаж — D единиц  
На борту имеется L телепортов, каждый из которых перемещает вас только на определенные палубы, за вход в телепорт требуется I единиц, за выход из телепорта J единиц.  
Помогите команде раскрыть секрет, разработав наименьшее по стоимости путешествие с хранилища на первой палубе до офиса на палубе N.
### Формат ввода:
В первой строке входного файла записаны целые числа N, U, D, I, J, L.  
Каждая из следующих L строк описывает соответствующий телепорт. Она начинается с числа K<sub>i</sub> — количества палуб, на которых останавливается i-й телепорт, за которым следует K<sub>i</sub> натуральных чисел — палубы, на которых останавливается этот телепорт (палубы для каждого телепорта задаются в возрастающем порядке).  
Ограничения: 0 ≤ U ≤ 10<sup>3</sup>, 0 ≤ D ≤ 10<sup>3</sup>, 0 ≤ I ≤ 10<sup>3</sup>, 0 ≤ J ≤ 10<sup>3</sup>, 0 ≤ L ≤ 500, 1 ≤ N ≤ 10<sup>6</sup>, 2 ≤ K<sub>i</sub> ≤ 10<sup>3</sup>, K<sub>1</sub> + K<sub>2</sub> + … +K<sub>L</sub> ≤ 10<sup>5</sup>.  
Количество палуб не превосходит 10<sup>6</sup>.
### Формат вывода:
В выходной файл выведите одно число — минимальную стоимость подъема.
## [T. Распространение вируса](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/T.cpp)
В этой задаче вы являетесь членом экипажа космического корабля в популярной игре Among Us. К сожалению, на корабле был запущен вирус, и теперь вам нужно добраться до медицинской комнаты в вершине t, чтобы найти лекарство.  
Корабль представлен положительно взвешенным неориентированным графом, и вы начинаете в вершине s. Однако, на корабле есть k источников вируса, которые могут блокировать некоторые ребра в графе. Вес ребра равен времени, необходимому для заражения ребра.  
Ваша скорость равна скорости распространения вируса, что означает, что вы можете двигаться так быстро, как и распространяется вирус. Сможете ли вы найти лекарство для вируса и спасти корабль до того, как будет слишком поздно? Ваша цель — найти кратчайший путь до вершины t, избегая блокированных ребер, вызванных источниками воды, и зараженных областей на корабле.
### Формат ввода:
В первой строке входных данных содержится три целых числа N, M и k — количество вершин, ребер и источников вируса (2 ≤ N ≤ 2 ⋅ 10<sup>5</sup>, 0 ≤ M ≤ 2 ⋅ 10<sup>5</sup>, 1 ≤ K < N).  
Во второй строке содержится K различных чисел a<sub>i</sub> — номера зараженных вершин в корабле (1 ≤ a<sub>i</sub> ≤ N).  
Следующие M строк описывают ребра. Каждое описание состоит из трех чисел x<sub>i</sub>, y<sub>i</sub> и l<sub>i</sub>, обозначающих номера вершин, которые соединяет i-е ребро, и его длину (1 ≤ x<sub>i</sub>, y<sub>i</sub> ≤ N, 1 ≤ l<sub>i</sub> ≤ 10<sup>9</sup>, x<sub>i</sub> ≠ y<sub>i</sub>).  
В последней строке входных данных содержится 2 числа s и t — номера вершин, где находитесь вы и лекарство (1 ≤ s, t ≤ N).
### Формат вывода:
Выведите единственное число — минимальное количество единиц времени, которое требуется для получения лекарства, либо «-1», если нет шансов.
## [U. Лекции от А](https://github.com/PlatonYadrov/Second_semester/blob/main/Algorithms/Third_contest/U.cpp)
Некий А. собирается выступить с лекциями по всему миру. Он знает, что постоянно нервничает при перелетах. На некоторых маршрутах он теряет вес от волнения, а на других — много ест и набирает вес.  
Известно, что чем больше весит А., тем лучше он прочтет лекцию, поэтому требуется спланировать перелеты так, чтобы вес А. на каждой лекции был максимально возможным. Он должен посещать города в том же порядке, в котором он читает свои лекции. При этом между лекциями он может посещать промежуточные города.
### Формат ввода:
Первая строка входного файла содержит три натуральных числа n, m и k — количество городов в мире, количество рейсов и количество лекций, которые он должен дать, соответственно (n ≤ 100, m ≤ 10<sup>4</sup>, 2 ≤ k ≤ 10<sup>4</sup>). Города пронумерованы числами от 1 до n.  
Следующие m строк содержат описание рейсов, по одному на строке. Рейс номер i описывается тремя числами b<sub>i</sub>, e<sub>i</sub> и w<sub>i</sub> — номер начального и конечного города рейса и предполагаемое изменение веса А. в миллиграммах (1 ≤ b<sub>i</sub>, e<sub>i</sub> ≤ n, −10<sup>5</sup> ≤ w<sub>i</sub> ≤ 10<sup>5</sup>).  
Последняя строка содержит числа a<sub>1</sub>, a<sub>2/sub>, …, a<sub>k</sub> — номера городов, в которых проводятся лекции. В начале тура он находится в городе a1.  
Гарантируется, что он может прочесть все лекции.
### Формат вывода:
Первая строка выходного файла должна содержать число s — количество рейсов, которые он должен сделать. Вторая строка должна содержать s чисел — номера используемых рейсов. Если существует такая последовательность маршрутов между концертами, что А. будет набирать вес неограниченно, то первая строка выходного файла должна содержать строку infinitely kind.
